# Брокеры сообщений на примере RabbitMQ 

## Взаимодействия между микросервисами

Основные способы взаимодействий между сервисами в микросервисной архитектуре:
1. Синхронное взаимодействие 

Отправитель ждет от получателя ответ на запрос.
Например, HTTP

2. Асинхронное взаимодействие
Отправитель не ждет от получателя ответ на запрос.
AMQP (Advanced Message Queuing Protocol)

![img](https://github.com/IlyaGall/C-/blob/main/47%20%D0%91%D1%80%D0%BE%D0%BA%D0%B5%D1%80%D1%8B%20%D1%81%D0%BE%D0%BE%D0%B1%D1%89%D0%B5%D0%BD%D0%B8%D0%B9/img/1.JPG)

1. Синхронное взаимодействие Отправитель ждет ответ на запрос Например, HTTP


![img](https://github.com/IlyaGall/C-/blob/main/47%20%D0%91%D1%80%D0%BE%D0%BA%D0%B5%D1%80%D1%8B%20%D1%81%D0%BE%D0%BE%D0%B1%D1%89%D0%B5%D0%BD%D0%B8%D0%B9/img/2.JPG)

2. Асинхронное взаимодействие Отправитель не ждет ответа на запрос.
AMQP (Advanced Message Queuing Protocol)

![img](https://github.com/IlyaGall/C-/blob/main/47%20%D0%91%D1%80%D0%BE%D0%BA%D0%B5%D1%80%D1%8B%20%D1%81%D0%BE%D0%BE%D0%B1%D1%89%D0%B5%D0%BD%D0%B8%D0%B9/img/3.JPG)

## Брокер сообщений

Сервис, который принимает сообщения от клиента и осуществляет их маршрутизацию и постановку во временное хранилище (очередь/лог) по принципу FIFO.

## AMQP

AMQP – протокол, позволяющий приложениям обмениваться сообщениями через специальные сервисы – посредники, называемые брокерами сообщений.
(https://www.rabbitmq.com/tutorials/amqp-concepts.html)

## Основные функции брокера

1. Обеспечение возможности асинхронной обработки сообщений, достигающееся наличием очередей

![img](https://github.com/IlyaGall/C-/blob/main/47%20%D0%91%D1%80%D0%BE%D0%BA%D0%B5%D1%80%D1%8B%20%D1%81%D0%BE%D0%BE%D0%B1%D1%89%D0%B5%D0%BD%D0%B8%D0%B9/img/4.JPG)

2. Централизованная маршрутизация

![img](https://github.com/IlyaGall/C-/blob/main/47%20%D0%91%D1%80%D0%BE%D0%BA%D0%B5%D1%80%D1%8B%20%D1%81%D0%BE%D0%BE%D0%B1%D1%89%D0%B5%D0%BD%D0%B8%D0%B9/img/5.JPG)

## PUSH и PULL архитектуры брокеров

![img](https://github.com/IlyaGall/C-/blob/main/47%20%D0%91%D1%80%D0%BE%D0%BA%D0%B5%D1%80%D1%8B%20%D1%81%D0%BE%D0%BE%D0%B1%D1%89%D0%B5%D0%BD%D0%B8%D0%B9/img/6.JPG)

## Очередь и лог

![img](https://github.com/IlyaGall/C-/blob/main/47%20%D0%91%D1%80%D0%BE%D0%BA%D0%B5%D1%80%D1%8B%20%D1%81%D0%BE%D0%BE%D0%B1%D1%89%D0%B5%D0%BD%D0%B8%D0%B9/img/7.JPG)


Очередь является временным хранилищем, лог - постоянным

Лог может только дополняться

Сообщения персистентны

Сообщения неизменяемы

### Не очередь, а лог

![img](https://github.com/IlyaGall/C-/blob/main/47%20%D0%91%D1%80%D0%BE%D0%BA%D0%B5%D1%80%D1%8B%20%D1%81%D0%BE%D0%BE%D0%B1%D1%89%D0%B5%D0%BD%D0%B8%D0%B9/img/8.JPG)

Очередь могут читать несколько физических консьюмеров, но не могут несколько логических

![img](https://github.com/IlyaGall/C-/blob/main/47%20%D0%91%D1%80%D0%BE%D0%BA%D0%B5%D1%80%D1%8B%20%D1%81%D0%BE%D0%BE%D0%B1%D1%89%D0%B5%D0%BD%D0%B8%D0%B9/img/9.JPG)

Лог могут читать несколько логических консьюмеров, но не могут несколько физических

Решение

![img](https://github.com/IlyaGall/C-/blob/main/47%20%D0%91%D1%80%D0%BE%D0%BA%D0%B5%D1%80%D1%8B%20%D1%81%D0%BE%D0%BE%D0%B1%D1%89%D0%B5%D0%BD%D0%B8%D0%B9/img/10.JPG)

Решением для очереди является создание копии очереди для каждого логического консьюмера

![img](https://github.com/IlyaGall/C-/blob/main/47%20%D0%91%D1%80%D0%BE%D0%BA%D0%B5%D1%80%D1%8B%20%D1%81%D0%BE%D0%BE%D0%B1%D1%89%D0%B5%D0%BD%D0%B8%D0%B9/img/11.JPG)


Решением для лога является разбиение лога на части (НЕ копии) называемые партициями

Порядок сообщений

В очереди сообщения идут по порядку, а при обработке физическими консьюмерами порядок нарушается 

Решение – синхронизация в логическом консьюмере (напрмер стейтмашина)

**То есть встроенного решения нет**

В логе сообщения идут по порядку но при отправке в разные партиции порядок нарушается

Решение – отправлять сообщения, относящиеся к одной и той же сущности, в одну партицию

**То есть встроенное решение есть**

## Клиентские библиотеки для работы с брокерами

Rebbit:

Библиотеки для работы в .Net
- RabbitMQ.Client
- Masstransit.RabbitMQ
- NServiceBus
- EasyNetQ
- …

Kafka:

- Confluent Kafka Client
- …

## Виды гарантий доставки

* 0.No guarantee – нет гарантий доставки
* 1.At most once (0 или 1 раз) – есть вероятность что сообщение будет потеряно
* 2.At least once (1 и более раз) – есть гарантия доставки (самый распространенный), но есть вероятность дублирования
* 3.Exactly once (строго 1 раз) – есть гарантия доставки и отсутствия дублирования. Сложно гарантировать, обеспечивается в основном с помощью паттернов инбокс, аутбокс и тд

1. No guarantee
- Реализуется установкой автоподтверждения доставки в true.
- Сохранили в бд, не закоммитили, испытали сбой – обработается дважды
- Не сохранили в бд, закоммитили, испытали сбой – не обработается
- Недетерминированное поведение системы
2. At most once
- Реализуется установкой автоподтверждения доставки в false, подтверждение делается перед
- логической обработкой.
- Закоммитили, сохранили в бд – обработается один раз
- Закоммитили, испытали сбой, не сохранили в бд – не обработается
3. At least once
- Реализуется установкой автоподтверждения доставки в false, подтверждение делается после обработки.
- Сохранили в бд, закоммитили – обработается один раз
- Сохранили в бд, испытали сбой, не закоммитили, повторили – обработается больше одного раза
4. Exactly once
- Реализуется созданием кастомного хранилища офсетов (Custom offset manager)

## RabbitMQ

RabbitMQ реализован на очередях

![img](https://github.com/IlyaGall/C-/blob/main/47%20%D0%91%D1%80%D0%BE%D0%BA%D0%B5%D1%80%D1%8B%20%D1%81%D0%BE%D0%BE%D0%B1%D1%89%D0%B5%D0%BD%D0%B8%D0%B9/img/12.JPG)


### Подключение помощью RabbitMQ.Client

![img](https://github.com/IlyaGall/C-/blob/main/47%20%D0%91%D1%80%D0%BE%D0%BA%D0%B5%D1%80%D1%8B%20%D1%81%D0%BE%D0%BE%D0%B1%D1%89%D0%B5%D0%BD%D0%B8%D0%B9/img/13.JPG)

```C#
var cf = new ConnectionFactory();
var conn = cf.newConnection();
// the .NET client calls channels "models"
var ch = conn.CreateModel();
// do some work
// close the channel when it is no Longer needed
ch.Close();
```