# Интеграция приложений

## Корпоративные системы

Корпоративные системы, также известные как enterprise системы, представляют собой крупномасштабные программные приложения, предназначенные для поддержки и управления основными бизнеспроцессами компании, информационными потоками и данными в различных отделах.
* Системы планирования ресурсов предприятия (ERP): интегрируют различные функции, такие как финансы, человеческие ресурсы и управление цепочками поставок, в одну комплексную систему.
Примеры: SAP, Oracle ERP.
* Системы управления взаимоотношениями с клиентами (CRM): управляют взаимодействием с клиентами, отслеживают продажи и автоматизируют маркетинг. Примеры: Salesforce, Microsoft Dynamics CRM.
* Системы управления цепочками поставок (SCM): управляют потоками товаров, информации и финансов, связанных с деятельностью цепочки поставок. Примеры: JDA Software, SAP SCM.
* Системы управления человеческими ресурсами (HRM): автоматизируют процессы управления персоналом, такие как расчет заработной платы, подбор персонала и управление данными сотрудников. Примеры: Workday, ADP.

![img](https://github.com/IlyaGall/C-/blob/main/45%20%D0%98%D0%BD%D1%82%D0%B5%D0%B3%D1%80%D0%B0%D1%86%D0%B8%D1%8F%20%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B9/Img/1.JPG)

### Характеристики корпоративных систем

* Масштабируемость
* Надежность: Например, система ERP, управляющая финансовыми транзакциями, должна обеспечивать точность данных и быть доступной 24/7, чтобы избежать любых финансовых потерь или проблем с соответствием.
* Модульность: Например, в системе ERP финансовый модуль можно обновить, не затрагивая модуль HR.
* Интеграция: Корпоративные системы часто интегрируются с другими системами внутри и за пределами организации для обеспечения бесперебойного потока данных. Эта интеграция может включать связывание системы ERP с системой CRM для синхронизации данных клиентов или интеграцию системы цепочки поставок со сторонним поставщиком логистических услуг.
* Настройка: Корпоративные системы часто необходимо настраивать для удовлетворения конкретных потребностей организации. Например, хотя система HRM может поставляться со стандартными функциями, компании может потребоваться настройка для соответствия местному трудовому законодательству или конкретным политикам компании.

### Почему нужна интеграция

* Создание единого информационного портала;
* Доступ к одним и тем же данным из разных систем;
* Вынесение общих функций, которые нужны в нескольких системах в разные сервисы
* Получение данных от партнеров, B2B интеграция;
* Распределенный бизнес-процесс, который охватывает несколько систем

### Доступ к одним и тем же данным и мастер-данные

В многих системах нужны одни и те же данные, чтобы точно знать, где данные самые верные вводят понятие мастер-системы и в нее сливают данные от разных систем по правилам

![img](https://github.com/IlyaGall/C-/blob/main/45%20%D0%98%D0%BD%D1%82%D0%B5%D0%B3%D1%80%D0%B0%D1%86%D0%B8%D1%8F%20%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B9/Img/2.JPG)


### Распределенный бизнес-процесс

![img](https://github.com/IlyaGall/C-/blob/main/45%20%D0%98%D0%BD%D1%82%D0%B5%D0%B3%D1%80%D0%B0%D1%86%D0%B8%D1%8F%20%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B9/Img/3.JPG)

Клиент хочет получить кредит, значит нужно обеспечить бизнес- процесс обработки заявки между несколькими подразделениями и разными системами

### Доступ к общим функциям

![img](https://github.com/IlyaGall/C-/blob/main/45%20%D0%98%D0%BD%D1%82%D0%B5%D0%B3%D1%80%D0%B0%D1%86%D0%B8%D1%8F%20%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B9/Img/4.JPG)

Небольшие функции, которые часто нужны выносятся в сервисы или подсистемы;

Примеры
1. Проверка клиента по паспортным данным
2. Отправка уведомлений (Email, Sms, Push)
3. Резервирование товара на складе

### Ключевые принципы разработки

При разработке корпоративных систем необходимо придерживаться определенных принципов для создания надежных, гибких и эффективных решений:

* Модульность и возможность повторного использования: Модульность подразумевает разбиение системы на более мелкие, автономные единицы или модули, каждый из которых отвечает за определенную функцию (например, финансы, HR, цепочка поставок).

* Масштабируемость и возможность обслуживания: Масштабируемость гарантирует, что система может расти вместе с компанией. Архитектура должна поддерживать добавление новых пользователей, увеличение объемов данных и дополнительных функций без необходимости полной переделки.
* Поддерживаемость фокусируется на том, чтобы сделать систему легкой для обновления и модификации. Это включает в себя написание чистого, хорошо документированного кода и следование передовым практикам в проектировании программного обеспечения, чтобы будущие разработчики могли легко понять и работать с системой.

* Безопасность и целостность данных: Безопасность имеет первостепенное значение в корпоративных системах, поскольку они часто обрабатывают конфиденциальные деловые и клиентские данные. Это включает в себя реализацию надежной аутентификации, шифрования и контроля доступа для защиты данных от несанкционированного доступа и нарушений.

* Целостность данных гарантирует, что информация в системе остается точной, последовательной и надежной в течение всего ее жизненного цикла. Это включает в себя реализацию проверок валидации, управления транзакциями и резервного копирования.

## Типы интеграции приложений 
### Что такое интеграция приложений
Интеграция приложений относится к процессу обеспечения совместной работы независимо разработанных приложений. В корпоративной среде предприятия часто используют несколько программных систем, каждая из которых предназначена для определенных функций, таких как финансы, HR, CRM или управление цепочками поставок. Эти системы должны взаимодействовать и обмениваться данными, чтобы обеспечить бесперебойную работу всей организации. Эффективная интеграция приложений позволяет данным перемещаться между системами, сокращая разрозненность и повышая эффективность.

Существует несколько типов интеграции приложений, каждый из которых имеет свой собственный набор преимуществ и недостатков.

### Подходы к интеграции
* передача файла;
* общая база данных (shared database);
* удаленный вызов процедур RPC
* Обмен сообщениями (API)

#### 1. Обмен файлами
Интеграция файлов подразумевает обмен данными между системами через файлы. Эти файлы могут быть в различных форматах, таких как CSV, XML, JSON или даже в собственных форматах. Системы генерируют и обмениваются файлами с предопределенными интервалами или в ответ на определенные триггеры, которые затем обрабатываются другими системами.

![img](https://github.com/IlyaGall/C-/blob/main/45%20%D0%98%D0%BD%D1%82%D0%B5%D0%B3%D1%80%D0%B0%D1%86%D0%B8%D1%8F%20%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B9/Img/5.JPG)

Когда использовать интеграцию файлов:

* Низкочастотный обмен данными: Идеально подходит для сценариев, где обмен данными в реальном времени не требуется, а достаточно пакетной обработки.
* Устаревшие системы: Полезно при интеграции старых систем, которые могут не поддерживать современные API или прямой доступ к базе данных.
* Простая передача данных: Подходит для простой передачи данных без необходимости сложных преобразований.

Плюсы:
* Простота.
* Слабая связь между системами.
Минусы:
* Задержка
* Обработка ошибок
* Масштабируемость

Многие сайты объявлений используют похожую систему для импорта объявлений от риэлторских агентств

![img](https://github.com/IlyaGall/C-/blob/main/45%20%D0%98%D0%BD%D1%82%D0%B5%D0%B3%D1%80%D0%B0%D1%86%D0%B8%D1%8F%20%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B9/Img/6.JPG)

#### 2. Подход с общей базой данных

В подходе с общей базой данных несколько приложений или служб получают доступ к общей базе данных. Эта база данных служит центральным репозиторием, где все соответствующие данные хранятся, обновляются и извлекаются различными системами.

![img](https://github.com/IlyaGall/C-/blob/main/45%20%D0%98%D0%BD%D1%82%D0%B5%D0%B3%D1%80%D0%B0%D1%86%D0%B8%D1%8F%20%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B9/Img/7.JPG)

Когда использовать общую базу данных:
* Доступ к данным в реальном времени: Идеально подходит для сценариев, когда различным системам требуется немедленный доступ к последним данным.
* Последовательное представление данных: Полезно, когда все системы должны работать с одним источником истины, обеспечивая согласованность во всей организации.
* Сложные запросы: Подходит для сред, где необходимы сложные межсистемные запросы и транзакции.

Плюсы:
* Согласованность данных.
* Обновления в реальном времени
* Упрощенная интеграция
Минусы:
* Узкие места производительности: при доступе нескольких систем к одной и той же базе данных производительность может стать проблемой, особенно если база данных не  оптимизирована для высокой степени параллелизма.
* Сложность управления: управление общей базой данных требует тщательного планирования, чтобы избежать конфликтов, таких как взаимоблокировки, и обеспечить безопасность данных в нескольких приложениях.
* Масштабируемость

В современной разработке считается антипаттерном, поскольку:
* Тесная связь между системами
* Отсутствие четкого владения.
* Масштабируемость
* Проблемы безопасности и контроля доступа
* Препятствует архитектуре микросервисов

Когда подход с общей базой данных может быть приемлемым:
* Устаревшие системы
* Простые, маломасштабные приложения.
* Временные решения
* Требования к централизованным данным

#### 3. Удаленный вызов процедур RPC

Удаленный вызов процедур (RPC) Ƃ это протокол, который одна программа может использовать для запроса службы у программы, расположенной на другом компьютере в сети.

RPC абстрагирует сложность сетевой коммуникации, позволяя программе выполнять процедуру (функцию) на удаленном сервере, как если бы это был локальный вызов функции.

Несколько протоколов реализуют шаблон RPC, включая REST, SOAP и gRPC. Каждый из них имеет свои собственные характеристики, сильные стороны и варианты использования.

![img](https://github.com/IlyaGall/C-/blob/main/45%20%D0%98%D0%BD%D1%82%D0%B5%D0%B3%D1%80%D0%B0%D1%86%D0%B8%D1%8F%20%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B9/Img/8.JPG)


##### RPC.REST (Representational State Transfer)

REST Ƃ это архитектурный стиль для распределенных систем. Это  набор ограничений, которые при применении к веб-службе обеспечивают желаемые свойства, такие как производительность, масштабируемость и модифицируемость.

Основные характеристики:
* Без сохранения состояния: каждый запрос от клиента к серверу должен содержать всю информацию, необходимую серверу для понимания и обработки запроса.
* Основанный на ресурсах: API RESTful предоставляют ресурсы, которые идентифицируются с помощью URI (унифицированных идентификаторов ресурсов).
* Использует методы HTTP: REST обычно использует стандартные методы HTTP (GET, POST, PUT, DELETE) для выполнения операций с ресурсами.
* Гибкость формата данных: хотя REST может возвращать данные в различных форматах, JSON используется чаще всего из-за его легковесности и простой интеграции с JavaScript.

Плюсы:
* Простота: REST прост и удобен в реализации. Он использует существующие вебстандарты, что делает его простым для разработчиков, знакомых с HTTP.
* Масштабируемость: Отсутствие состояния REST помогает распределить рабочую нагрузку между серверами, улучшая масштабируемость.
* Кэшируемость: Ответы от RESTful-сервисов могут кэшироваться клиентами или посредниками, что повышает производительность и снижает нагрузку на сервер.
Минусы:
* Накладные расходы
* Менее подходит для сложных операций: REST ориентирован на ресурсы, поэтому сложные транзакции между несколькими ресурсами могут быть сложно смоделировать и выполнить.


##### RPC.SOAP (Simple Object Access Protocol)

SOAP Ƃ это протокол для обмена структурированной информацией при реализации веб-сервисов. Он использует XML для форматирования сообщений и обычно использует HTTP, SMTP или другие протоколы для согласования и передачи сообщений.

Основные характеристики:
* Формальные стандарты: SOAP Ƃ это формальный протокол со строгими стандартами, регулируемый W3C.
* Структура конверта: сообщения SOAP упакованы в стандартный формат,  содержащий заголовок и тело, что облегчает сложную обработку, такую как безопасность и транзакции.
* Обширные стандарты WS:* SOAP поддерживает широкий спектр стандартов (WS-Security, WS-ReliableMessaging, WS-Transaction) для таких функций, как безопасность, надежность и транзакции.

Плюсы:
* Расширяемость: протокол SOAP является высокорасширяемым и поддерживает такие функции, как безопасность (шифрование, аутентификация), транзакции и маршрутизация сообщений, что делает его пригодным для приложений корпоративного уровня.
* Независимость от протокола
* Формальная обработка ошибок
Минусы:
* Сложность: SOAP сложнее реализовать и поддерживать по сравнению с REST. Строгий формат XML и необходимость придерживаться нескольких стандартов могут привести к увеличению времени разработки.
* Накладные расходы на производительность


##### RPC.gRPC (gRPC Remote Procedure Call)
gRPC Ƃ это высокопроизводительная среда RPC с открытым исходным кодом, разработанная Google. Она использует буферы протоколов (protobufs) в качестве языка определения интерфейса и поддерживает несколько языков программирования.

Основные характеристики:
* Высокая производительность: gRPC разработан для связи с низкой задержкой и высокой пропускной способностью, что делает его подходящим для микросервисов и приложений реального времени.
* Строго типизированный: gRPC использует protobufs, которые обеспечивают строгую, строго типизированную схему для сообщений, снижая вероятность ошибок.
* Двунаправленная потоковая передача: gRPC поддерживает потоковую передачу, позволяя клиентам и серверам непрерывно отправлять и получать данные в реальном времени.
* Основанный на HTTP/2: gRPC использует HTTP/2, что обеспечивает такие функции, как мультиплексирование (несколько запросов по одному соединению), управление потоком и сжатие заголовков.

Плюсы:
* Эффективность: gRPC очень эффективен благодаря использованию двоичного формата данных (protobuf) и HTTP/2. Это приводит к уменьшению размера сообщений и более быстрой обработке.
* Поддержка нескольких языков
* Возможности потоковой передачи
Минусы:
* Сложность: gRPC требует большей настройки и понимания таких концепций, как буферы протоколов и HTTP/2, по сравнению с более простыми службами RESTful.
* Менее удобочитаемо
* Ограниченная поддержка браузеров

##### Выбор правильного протокола RPC

Выбор между REST, SOAP и gRPC зависит от конкретных потребностей вашего приложения:
* REST подходит для большинства веб-приложений, особенно когда простота, масштабируемость и гибкость являются ключевыми.
* SOAP идеально подходит для приложений корпоративного уровня, требующих строгой безопасности, сложных транзакций и соблюдения формальных стандартов.
* gRPC лучше всего подходит для высокопроизводительной связи в реальном времени в микросервисах или распределенных системах, особенно когда важны эффективность и языковая совместимость.

##### Rest-like vs Rpc-like

REST-like:
```
GET api/customers?fullName="Jack"
GET api/customers/{customerld}/orders POST api/customers
PUT api/customers
DELETE api/customers/{customerld}
POST api/customers/{customerld}/status
```

RPC-like:
```
GET api/getCustomers
GET api/getCustomerOrders
POST api/createCustomer 
POST api/changeStatus 
POST api/changeCardName
```

Основная проблема RPC-like API - это расширяемость, при таком подходе мы должны проделать больше работы для описания семантики ответов и в него часто надо вносить изменения. REST стиль часто ведет к меньшему числу конечных точек и к более простой расширяемости

## 4. Контракты

Контракт на обслуживание Ƃ это формальное соглашение между поставщиком услуг и потребителем услуг, которое определяет интерфейс, поведение и правила взаимодействия для услуги. Он определяет, что делает услуга, как к ней следует обращаться, а также ожидаемые входные и выходные данные.


Это очень важное понятие для SOA, так как четкие и формализованные правила взаимодействия позволяют обеспечить долгосрочную поддержку и использование сервисов без  необходимости изучать их программный код.

![img](https://github.com/IlyaGall/C-/blob/main/45%20%D0%98%D0%BD%D1%82%D0%B5%D0%B3%D1%80%D0%B0%D1%86%D0%B8%D1%8F%20%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B9/Img/9.JPG)

Ключевые аспекты контракта на обслуживание:
* Операции: определяет действия или методы, предоставляемые услугой. Например, услуга обработки платежей может включать такие операции, как processPayment или refundPayment.
* Сообщения ввода и вывода: определяет структуру данных, которые должны быть предоставлены для вызова операции, и то, что потребитель может ожидать в качестве ответа. Сюда часто входят сведения о формате (например, XML, JSON), типах данных и обязательных/необязательных полях.
* Протоколы и привязки: определяет, как можно получить доступ к услуге, включая протокол связи (например, HTTP, HTTPS, SMTP) и кодировку данных (например, XML,JSON)

Ключевые аспекты контракта на обслуживание:
* Требования безопасности: описывает механизмы безопасности, которые должны использоваться при взаимодействии со службой, такие как методы аутентификации, шифрования и авторизации.
* Соглашения об уровне обслуживания (SLA): определяет нефункциональные аспекты, такие как доступность, производительность и обработка ошибок. Например, контракт может гарантировать определенное время безотказной работы или время отклика.


1. Если мы имеем доступ к исходному коду, то мы можем посмотреть контракт прямо в реализации, хотя не факт, что версия кода будет соответствовать версии, с которой надо интегрироваться;
2. Вести документацию контракта сервиса в каком-то формате в wiki или текстовых документах, трудоемко и требует большого количества ручных операций для системного  аналитика или разработчика - невозможно при большом количестве сервисов;
3. Использовать протоколы и спецификации, которые предполагают публикацию контракта программным способом;

![img](https://github.com/IlyaGall/C-/blob/main/45%20%D0%98%D0%BD%D1%82%D0%B5%D0%B3%D1%80%D0%B0%D1%86%D0%B8%D1%8F%20%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B9/Img/10.JPG)

### WSDL (язык описания веб-сервисов)

WSDL Ƃ это основанный на XML язык, используемый специально для описания функциональности, предлагаемой вебсервисом SOAP. Он служит машиночитаемым документом, который определяет контракт сервиса стандартизированным образом, позволяя как поставщику сервиса, так и потребителю понять, как взаимодействовать с сервисом.

![img](https://github.com/IlyaGall/C-/blob/main/45%20%D0%98%D0%BD%D1%82%D0%B5%D0%B3%D1%80%D0%B0%D1%86%D0%B8%D1%8F%20%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B9/Img/11.JPG)

Ключевые компоненты WSDL:
* Определения: Корневой элемент документа WSDL, который определяет имя сервиса и ссылки на другие компоненты.
* Типы: Определяет типы данных, используемые сервисом. Обычно он использует схему XML (XSD) для описания сложных структур данных (например, пользовательских типов данных, таких как Customer, Order).
* Сообщения: Определяет данные, которыми обмениваются сервис и клиент. Каждое сообщение состоит из одной или нескольких частей, и каждая часть связана с типом данных, определенным в разделе Типы.

* PortType: Описывает операции (или методы), доступные в веб-сервисе, а также входные и выходные сообщения для каждой операции. По сути, это интерфейс веб-службы.
* Привязки: Определяет протокол и формат данных для каждой операции. Например, он может указывать, что следует использовать SOAP 1.1 или SOAP 1.2 вместе с HTTP в качестве транспортного протокола.
* Служба: Указывает фактическую конечную точку (т. е. URL), где можно получить доступ к службе. Он привязывает операции, определенные в PortType, к сетевому адресу.

* PortType: Описывает операции (или методы), доступные в веб-сервисе, а также входные и выходные сообщения для каждой операции. По сути, это интерфейс веб-службы.
* Привязки: Определяет протокол и формат данных для каждой операции. Например, он может указывать, что следует использовать SOAP 1.1 или SOAP 1.2 вместе с HTTP в качестве транспортного протокола.
* Служба: Указывает фактическую конечную точку (т. е. URL), где можно получить доступ к службе. Он привязывает операции, определенные в PortType, к сетевому адресу.

#### Contract vs WSDL
1. Сложная реализация специальных протоколов;
2. Службы WSDL/SOAP и клиенты на разных платформах могут иметь возможность обеспечения совместимости из-за сложности реализации спецификации;
3. Тяжелый в описаниях и поддержке форматов;
4. Как и другие технологии, подобные RPC, с помощью подробного описания контракта, это приводит к сложности с расчетом;
5. На данный момент не существует предпосылок к обеспечению связи в новых сервисах;
6. Контракты на обслуживание определяют формальное соглашение между поставщиком услуг и потребителем, описывая, какие услуги предлагаются, как к ним следует получать доступ и ожидаемые входы/выходы.
7. WSDL Ƃ это конкретная реализация контракта на обслуживание для вебсервисов SOAP, описывающая операции, сообщения, типы данных, протоколы и конечные точки в стандартизированном формате XML.


### Обмен сообщениями (шаблон из 4 шагов)

Суть шаблона
1. Есть системы А,В и С с определенной функциональностью и данными;
2. Необходимо обеспечить обмен данными и доступ к функциям систем с гарантированной доставкой запросов, учитывающий вероятность отказа одной из систем;
3. Также желательно снизить число точек интеграции между системами, чтобы уменьшить связность систем и можно было без доработок менять компоненты;
4. Реализуем асинхронный обмен сообщениями вместо того, чтобы ждать ответа на запрос сохраним его в системе обмена сообщений (Шине сообщений) и обработаем после, когда  система получатель будет готова это сделать. Системы не знают друг о друге, а только о шине;

Основное назначение - убрать явную связь между системами, снизить нагрузку и вероятность отказа, сохранив при этом скорость обработки информации. По факту самый продвинутый и лучший способ интеграции, взамен платим сложностью и отсутствием мгновенной обратной связи, так как все асинхронно.

![img](https://github.com/IlyaGall/C-/blob/main/45%20%D0%98%D0%BD%D1%82%D0%B5%D0%B3%D1%80%D0%B0%D1%86%D0%B8%D1%8F%20%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B9/Img/12.JPG)

* Канал сообщений - средство передачи сообщений от одной системы к другой, по сути является логическим адресом, который может зависеть от конкретной реализации, например, адрес очереди.
* Сообщение - единица данных, которые передаются в системе, это может быть событие, команда или просто данные (например, кредитная заявка)
* Очередь - структура FIFO, куда складываются сообщения по определенным правилам
* Производитель сообщений (Producer) - система, генерирующая сообщения и отправляющая их по некоторому адресу (Например, агрегатор заявок)
* Потребитель сообщений (Consumer) - система, получающая сообщения из канала, очереди (например, CBS)
* Маршрутизация - процесс определения куда нужно доставить сообщение, в какой канал, очередь

Это максимально общая терминология на основе книги "Паттерны интеграции корпоративных приложений". Большинство систем обмена сообщений, которые есть на рынке используют свои термины для этих понятий

### Брокер сообщений

Суть шаблона
1. Если мы хотим построить обмен сообщениями между системами А, В, С нам нужно сделать так, чтобы кто-то определял, как сообщение будет отправлено по логическому адресу канала;
2. Мы можем ввести специальную сущность, которая будет обрабатывать сообщения от продюсеров, определять логику маршрутизации и отправлять их консюмерам, этой сущностью будет Брокер сообщений, приложения знают только о брокере, но не о системах;

![img](https://github.com/IlyaGall/C-/blob/main/45%20%D0%98%D0%BD%D1%82%D0%B5%D0%B3%D1%80%D0%B0%D1%86%D0%B8%D1%8F%20%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B9/Img/13.JPG)

### Enterprise Service Bus / Message Bus / Шина сообщений

Брокер сообщений - это конкретный компонент, который отвечает за доставку и маршрутизацию Сам процесс обмена сообщениями может быть сложнее, например, мы хотим преобразовать сообщения от одного формата в другой через преобразователь, подключить систему к обмену сообщениями через сервис-адаптер, определить по каким правилам формировать очереди и т.д.

![img](https://github.com/IlyaGall/C-/blob/main/45%20%D0%98%D0%BD%D1%82%D0%B5%D0%B3%D1%80%D0%B0%D1%86%D0%B8%D1%8F%20%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B9/Img/14.JPG)

Плюсы
1. Решается проблема нагрузки, компоненты обрабатывают сообщения асинхронно и в том темпе, в котором могут;
2. Нет прямой связи между компонентами, сообщение может быть обработано множеством компонентов;
3. Отказоустойчивость и масштабирование;
Минусы
1. Сложнее в реализации;
2. Нет прямой обратной связи, как в случае с синхронным вызовом;
3. Нужен брокер сообщений, при его отказе система не работает, но они, как правило, являются устойчивыми к отказу компонентами;

## Методы интеграции приложений 

### Методы интеграции приложений
Существует несколько методов интеграции приложений, каждый из которых имеет свой собственный набор преимуществ и недостатков. Выбор метода часто зависит от размера и сложности организации, конкретного варианта использования и технической среды.
1. Интеграция точка-точка
2. Интеграция Hub-and-Spoke
3. Enterprise Service Bus (ESB)
4. Интеграция на основе API

### 1. Интеграция точка-точка

В этом методе каждое приложение напрямую подключается к каждому другому приложению, с которым ему необходимо взаимодействовать. Данные передаются между системами с помощью определенных, жестко запрограммированных соединений.

![img](https://github.com/IlyaGall/C-/blob/main/45%20%D0%98%D0%BD%D1%82%D0%B5%D0%B3%D1%80%D0%B0%D1%86%D0%B8%D1%8F%20%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B9/Img/15.JPG)


Плюсы:
* Простота внедрения в небольших средах.
* Прямая связь между системами.
Минусы:
* Не масштабируется: по мере увеличения количества приложений количество подключений растет экспоненциально, что затрудняет управление системой.
* Обслуживание становится обременительным, поскольку изменения в одной системе требуют обновлений для нескольких подключений.

Пример: Небольшая компания, использующую отдельное бухгалтерское программное обеспечение и платформу электронной коммерции. Интеграция «точка-точка» подразумевает прямое связывание этих двух систем, чтобы данные о продажах с платформы электронной коммерции автоматически обновляли систему учета.

### 2. Интеграция Hub-and-Spoke

Этот метод использует центральный хаб для управления коммуникацией между приложениями. Каждое приложение подключается к хаб, который обрабатывает маршрутизацию сообщений, преобразование и посредничество протоколов. Хаб отвечает за обеспечение передачи данных в правильное место назначения.

![img](https://github.com/IlyaGall/C-/blob/main/45%20%D0%98%D0%BD%D1%82%D0%B5%D0%B3%D1%80%D0%B0%D1%86%D0%B8%D1%8F%20%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B9/Img/16.JPG)

Плюсы:
* Централизованное управление упрощает управление интеграциями.
* Упрощает добавление или удаление приложений, поскольку нужно настроить только подключение к хабу.
Минусы:
* Хаб может стать единой точкой отказа.
* Может стать сложным, если концентратор должен обрабатывать множество различных типов протоколов связи и преобразований данных.

Пример: Производственная компания среднего размера может использовать интеграцию Hub-and-Spoke для связи своих систем ERP, CRM и цепочки поставок. Хаб будет управлять потоками данных между этими системами, например, отправкой сведений о заказах клиентов из CRM в ERP для обработки, а затем в систему цепочки поставок для выполнения..

### 3. Enterprise Service Bus (ESB)
ESB Ƃ это усовершенствованная форма модели Hub-and-Spoke.

Это платформа промежуточного программного обеспечения, которая позволяет различным приложениям взаимодействовать друг с другом, предоставляя магистраль обмена сообщениями.

ESB обрабатывает преобразование сообщений, маршрутизацию и оркестровку, обеспечивая сложные взаимодействия между системами.

![img](https://github.com/IlyaGall/C-/blob/main/45%20%D0%98%D0%BD%D1%82%D0%B5%D0%B3%D1%80%D0%B0%D1%86%D0%B8%D1%8F%20%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B9/Img/17.JPG)

Плюсы:
* Высокая масштабируемость и гибкость, подходит для сложных сред.
* Разделяет приложения, что упрощает изменение или замену отдельных систем.
Минусы:
* Может быть сложным и дорогим для внедрения.
* Требует квалифицированного персонала для управления и обслуживания.

Пример: крупное финансовое учреждение может использовать ESB для интеграции нескольких приложений, включая онлайн-банкинг, управление взаимоотношениями с клиентами и системы обнаружения мошенничества. ESB будет маршрутизировать транзакции между этими системами, гарантируя, что каждая из них получит необходимые данные в правильном формате.

### 4. Интеграция на основе API
API (интерфейсы прикладного программирования) позволяют приложениям взаимодействовать, предоставляя определенные функции в качестве услуг, которые могут потреблять другие приложения. Современные системы все больше полагаются на API для упрощения интеграции, особенно в облачных и
микросервисных архитектурах.

Плюсы:
* Очень гибкий и поддерживает широкий спектр сценариев интеграции.
* Облегчает обмен данными в реальном времени и идеально подходит для современных облачных архитектур.
Минусы:
* Требует четко определенных и стабильных API.
* Безопасность и управление версиями API требуют тщательного управления.

Пример: глобальная компания электронной коммерции может использовать API для интеграции своего интернет-магазина с платежными шлюзами, службами доставки и платформами аналитики клиентов. Когда клиент совершает покупку, API позволит платформе электронной коммерции автоматически отправлять платежные реквизиты на платежный шлюз, а информацию о заказе Ƃ в службу доставки.

![img](https://github.com/IlyaGall/C-/blob/main/45%20%D0%98%D0%BD%D1%82%D0%B5%D0%B3%D1%80%D0%B0%D1%86%D0%B8%D1%8F%20%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B9/Img/18.JPG)

## Микросервисы

Хронология развития архитектур

![img](https://github.com/IlyaGall/C-/blob/main/45%20%D0%98%D0%BD%D1%82%D0%B5%D0%B3%D1%80%D0%B0%D1%86%D0%B8%D1%8F%20%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B9/Img/19.JPG)


Что такое архитектура микросервисов?

Архитектура микросервисов Ƃ это подход к разработке программного обеспечения, при котором большое приложение делится на более мелкие, слабосвязанные сервисы, каждый из которых отвечает за определенную функциональность. В отличие от традиционных монолитных архитектур, где все компоненты взаимосвязаны и взаимозависимы, микросервисы работают независимо и взаимодействуют друг с другом через четко определенные API.

Пример: Маркетплейс. Вместо того чтобы иметь единое монолитное приложение, которое обрабатывает все, от списков продуктов до обработки платежей и аутентификации пользователей, платформа разбита на микросервисы. Один микросервис может управлять каталогом продуктов, другой Ƃ платежами, а третий Ƃ учетными записями пользователей. Эти сервисы работают независимо, но работают вместе, чтобы обеспечить бесперебойный пользовательский интерфейс.

### Основные характеристики микросервисов
**Независимое развертывание:**

Каждый микросервис может разрабатываться, тестироваться, развертываться и масштабироваться независимо от других. Это означает, что обновления или изменения могут быть внесены в один микросервис, не влияя на всю систему.

Пример: в системе онлайн-банкинга сервис, отвечающий за обработку транзакций, может быть обновлен, не нарушая работу сервисов, отвечающих за управление счетами или поддержку клиентов.

**Децентрализованное управление данными:**

Микросервисы часто имеют собственные базы данных или хранилища данных, которые оптимизированы для их конкретных потребностей. Этот децентрализованный подход контрастирует с монолитными системами, где одна база данных используется совместно всеми компонентами.

Пример: интернет-магазин может использовать разные базы данных для управления запасами, заказами клиентов и отзывами пользователей. Каждый микросервис получает доступ только к тем данным, которые ему нужны, что повышает производительность и снижает сложность.

**Изоляция неисправностей:**

Если один микросервис выходит из строя, это не обязательно приводит к сбою всей системы. Изоляция сбоев гарантирует, что проблемы в одной части системы не перекинутся на другие части, что повышает общую устойчивость системы.

Пример: в платформе потоковой передачи на основе микросервисов, такой как Netflix, если в системе рекомендаций возникают проблемы, пользователи все равно могут просматривать и смотреть видео без перерыва.

**Масштабируемость:**
Микросервисы можно масштабировать индивидуально в зависимости от спроса. Например, если сервис, обрабатывающий входы пользователей, испытывает всплеск трафика, его можно масштабировать независимо от остальной части приложения. 

Пример: платформа электронной коммерции может столкнуться с всплеском трафика во время праздничной распродажи. Микросервис, обрабатывающий платежи, можно масштабировать, чтобы справиться с возросшей нагрузкой, в то время как другие сервисы остаются на своей обычной мощности.

### Независимые части

![img](https://github.com/IlyaGall/C-/blob/main/45%20%D0%98%D0%BD%D1%82%D0%B5%D0%B3%D1%80%D0%B0%D1%86%D0%B8%D1%8F%20%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B9/Img/20.JPG)

### Почему микросервисы?
Внедрение микросервисов быстро растет, особенно среди крупных предприятий, благодаря нескольким ключевым преимуществам:
* Повышенная гибкость и скорость разработки
* Гибкость в выборе технологий
* Более простое обслуживание и обновления
* Устойчивость и отказоустойчивость
* Масштабируемость

### Проблемы масштабируемости в монолитах
Масштабирование всего приложения по сравнению с отдельными службами.

Неэффективность ресурсов.

![img](https://github.com/IlyaGall/C-/blob/main/45%20%D0%98%D0%BD%D1%82%D0%B5%D0%B3%D1%80%D0%B0%D1%86%D0%B8%D1%8F%20%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B9/Img/21.JPG)

### Микросервисы: Независимое масштабирование 

Мелкозернистая масштабируемость.

![img](https://github.com/IlyaGall/C-/blob/main/45%20%D0%98%D0%BD%D1%82%D0%B5%D0%B3%D1%80%D0%B0%D1%86%D0%B8%D1%8F%20%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B9/Img/22.JPG)

### Модульный монолит для управляемости
* Модульные границы и инкапсуляция.
* Постепенный переход к микросервисам.

![img](https://github.com/IlyaGall/C-/blob/main/45%20%D0%98%D0%BD%D1%82%D0%B5%D0%B3%D1%80%D0%B0%D1%86%D0%B8%D1%8F%20%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B9/Img/23.JPG)

### Проблемы разработки в монолитах
* Взаимозависимости, замедляющие разработку.
* Длительные циклы тестирования и развертывания

![img](https://github.com/IlyaGall/C-/blob/main/45%20%D0%98%D0%BD%D1%82%D0%B5%D0%B3%D1%80%D0%B0%D1%86%D0%B8%D1%8F%20%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B9/Img/24.JPG)

## 10 ошибок

### Микросервисная архитектура

![img](https://github.com/IlyaGall/C-/blob/main/45%20%D0%98%D0%BD%D1%82%D0%B5%D0%B3%D1%80%D0%B0%D1%86%D0%B8%D1%8F%20%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B9/Img/25.JPG)

![img](https://github.com/IlyaGall/C-/blob/main/45%20%D0%98%D0%BD%D1%82%D0%B5%D0%B3%D1%80%D0%B0%D1%86%D0%B8%D1%8F%20%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B9/Img/26.JPG)

### Распределенный монолит

![img](https://github.com/IlyaGall/C-/blob/main/45%20%D0%98%D0%BD%D1%82%D0%B5%D0%B3%D1%80%D0%B0%D1%86%D0%B8%D1%8F%20%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B9/Img/27.JPG)

### Микросервисы всегда лучше

![img](https://github.com/IlyaGall/C-/blob/main/45%20%D0%98%D0%BD%D1%82%D0%B5%D0%B3%D1%80%D0%B0%D1%86%D0%B8%D1%8F%20%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B9/Img/28.JPG)

Когда действительно лучше

![img](https://github.com/IlyaGall/C-/blob/main/45%20%D0%98%D0%BD%D1%82%D0%B5%D0%B3%D1%80%D0%B0%D1%86%D0%B8%D1%8F%20%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B9/Img/29.JPG)

### 2. (Совместное хранилище данных или моделей) Shared Data Store or Models

![img](https://github.com/IlyaGall/C-/blob/main/45%20%D0%98%D0%BD%D1%82%D0%B5%D0%B3%D1%80%D0%B0%D1%86%D0%B8%D1%8F%20%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B9/Img/30.JPG)

Как лучше

![img](https://github.com/IlyaGall/C-/blob/main/45%20%D0%98%D0%BD%D1%82%D0%B5%D0%B3%D1%80%D0%B0%D1%86%D0%B8%D1%8F%20%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B9/Img/31.JPG)

Пример

![img](https://github.com/IlyaGall/C-/blob/main/45%20%D0%98%D0%BD%D1%82%D0%B5%D0%B3%D1%80%D0%B0%D1%86%D0%B8%D1%8F%20%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B9/Img/32.JPG)

![img](https://github.com/IlyaGall/C-/blob/main/45%20%D0%98%D0%BD%D1%82%D0%B5%D0%B3%D1%80%D0%B0%D1%86%D0%B8%D1%8F%20%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B9/Img/33.JPG)

### 3. Слишком большие микросервисы

ПРОСТОЕ ПРАВИЛО : наименьшие возможные микросервисы без непрерывного(болтливого) общения между сервисами

![img](https://github.com/IlyaGall/C-/blob/main/45%20%D0%98%D0%BD%D1%82%D0%B5%D0%B3%D1%80%D0%B0%D1%86%D0%B8%D1%8F%20%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B9/Img/34.JPG)

### 4. Слишком маленькие микросервисы

![img](https://github.com/IlyaGall/C-/blob/main/45%20%D0%98%D0%BD%D1%82%D0%B5%D0%B3%D1%80%D0%B0%D1%86%D0%B8%D1%8F%20%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B9/Img/35.JPG)

Как лучше

![img](https://github.com/IlyaGall/C-/blob/main/45%20%D0%98%D0%BD%D1%82%D0%B5%D0%B3%D1%80%D0%B0%D1%86%D0%B8%D1%8F%20%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B9/Img/36.JPG)

### 5. Начинать с начала

![img](https://github.com/IlyaGall/C-/blob/main/45%20%D0%98%D0%BD%D1%82%D0%B5%D0%B3%D1%80%D0%B0%D1%86%D0%B8%D1%8F%20%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B9/Img/37.JPG)

[ссылка](https://learn.microsoft.com/en-us/azure/architecture/patterns/strangler-fig)

### 6. Связь через сквозные проблемы

https://datalust.co/seq

Пример: Распределенное ведение журнала — это сложно
* Централизованно без связи
* Сторонние решения, такие как Seq
* Seq: «Интеллектуальный сервер поиска, анализа и оповещения, созданный специально для современных структурированных данных журнала»
* Поддерживает .NET, Java, NodeJS, Ruby, Go, Python и многое другое.
* По своей сути отказоустойчивый, обеспечивает конечную согласованность

### 7. Использование синхронной коммуникации

![img](https://github.com/IlyaGall/C-/blob/main/45%20%D0%98%D0%BD%D1%82%D0%B5%D0%B3%D1%80%D0%B0%D1%86%D0%B8%D1%8F%20%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B9/Img/38.JPG)

![img](https://github.com/IlyaGall/C-/blob/main/45%20%D0%98%D0%BD%D1%82%D0%B5%D0%B3%D1%80%D0%B0%D1%86%D0%B8%D1%8F%20%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B9/Img/39.JPG)

![img](https://github.com/IlyaGall/C-/blob/main/45%20%D0%98%D0%BD%D1%82%D0%B5%D0%B3%D1%80%D0%B0%D1%86%D0%B8%D1%8F%20%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B9/Img/40.JPG)


### 8. Критические изменения в Event контрактах

![img](https://github.com/IlyaGall/C-/blob/main/45%20%D0%98%D0%BD%D1%82%D0%B5%D0%B3%D1%80%D0%B0%D1%86%D0%B8%D1%8F%20%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B9/Img/41.JPG)


* 01 Нет новых обязательных полей, только необязательные поля (с задокументированными значениями по умолчанию).
* 02 Нераспознанные поля игнорируются (но пересылаются)
* 03 Потребители необязательных полей используют значения по умолчанию, если они отсутствуют
* 04 Когда 1-3 не могут быть удовлетворены, это новый тип события

### 9. Не автоматизированы сборка и релиз

![img](https://github.com/IlyaGall/C-/blob/main/45%20%D0%98%D0%BD%D1%82%D0%B5%D0%B3%D1%80%D0%B0%D1%86%D0%B8%D1%8F%20%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B9/Img/42.JPG)

### 10. Несоответствующие команды

![img](https://github.com/IlyaGall/C-/blob/main/45%20%D0%98%D0%BD%D1%82%D0%B5%D0%B3%D1%80%D0%B0%D1%86%D0%B8%D1%8F%20%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B9/Img/43.JPG)


![img](https://github.com/IlyaGall/C-/blob/main/45%20%D0%98%D0%BD%D1%82%D0%B5%D0%B3%D1%80%D0%B0%D1%86%D0%B8%D1%8F%20%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B9/Img/44.JPG)

## Список материалов для изучения
1. https://opensource.zalando.com/restful-api-guidelines/#api-naming
2. https://ru.wikipedia.org/wiki/AMQP
3. ƈСоздание микросервисовƉ Сэм Ньюмен
4. "Enterprise Integration Patterns: Designing, Building, and Deploying Messaging Solutions" Gregor Hohpe
and Bobby Woolf
5. "RESTful Web APIs: Services for a Changing World" Leonard Richardson, Mike Amundsen, and Sam Ruby
6. https://12factor.net/
7. https://www.youtube.com/watch?v=z8qhToMtYRc
8. https://konghq.com/resources/e-book/monolith-to-microservices-migration?utm_source=google&utm_
medium=cpc&utm_campaign=microservices&utm_term=microservices%20architecture&utm_content=ad
opting-microservices_ebook_search&gad_source=2&gclid=Cj0KCQjwz7C2BhDkARIsAA_SZKYvCK4x3S_z
-K2OiEgeF0sKTChMqFTLwp_dAZ29K6qOGkET5r8j_OMaAo15EALw_wcB
