# Структурные шаблоны проектирования

## Adapter


![img](https://github.com/IlyaGall/C-/blob/main/43%20%D0%A1%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D0%BD%D1%8B%D0%B5%20%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B%20%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F/IMG/1.JPG)


Когда вы хотите использовать сторонний класс, но его интерфейс не соответствует остальному коду приложения.

Адаптер позволяет создать объект-прокладку, который будет превращать вызовы приложения в формат, понятный стороннему классу.

![img](https://github.com/IlyaGall/C-/blob/main/43%20%D0%A1%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D0%BD%D1%8B%D0%B5%20%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B%20%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F/IMG/2.JPG)

+ Скрывает от клиента подробности преобразования разных интерфейсов
- Дополнительные классы

Проблема:

Существует совокупность классов с большим функционалом. Нашему классу требуется упрощенная часть этого функционала

## Facade

![img](https://github.com/IlyaGall/C-/blob/main/43%20%D0%A1%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D0%BD%D1%8B%D0%B5%20%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B%20%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F/IMG/3.JPG)

![img](https://github.com/IlyaGall/C-/blob/main/43%20%D0%A1%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D0%BD%D1%8B%D0%B5%20%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B%20%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F/IMG/4.JPG)

Когда вам нужно представить простой или урезанный интерфейс к сложной подсистеме.

+ Изолирует клиентов от компонентов сложной подсистемы.
- Фасад рискует стать божественным объектом, привязанным ко всем классам программы.

## Proxy (заместитель)

Проблема:
Объект совершает тяжелую операцию Но в некоторых случаях она случаях может выполняться простым способом В этих случаях не нужно делать ее тяжелым способом

![img](https://github.com/IlyaGall/C-/blob/main/43%20%D0%A1%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D0%BD%D1%8B%D0%B5%20%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B%20%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F/IMG/5.JPG)

![img](https://github.com/IlyaGall/C-/blob/main/43%20%D0%A1%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D0%BD%D1%8B%D0%B5%20%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B%20%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F/IMG/6.JPG)

• Для каких случаев:
    • Логирование запросов
    • Кэширование ответов
    • Защита доступа
    • …
• Используется композиция или наследование
• Прокси-класс сам управляет жизнью проксируемого класса


+ Позволяет контролировать сервисный объект незаметно для клиента.
+ Может работать, даже если сервисный объект ещё не создан.
+ Может контролировать жизненный цикл служебного объекта.

- Усложняет код программы из-за введения дополнительных классов.
- Увеличивает время отклика от сервиса.

## Decorator / Wrapper (обертка)

Проблема:
Нужно на лету добавлять объекту типовые обязанности

![img](https://github.com/IlyaGall/C-/blob/main/43%20%D0%A1%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D0%BD%D1%8B%D0%B5%20%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B%20%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F/IMG/7.JPG)

![img](https://github.com/IlyaGall/C-/blob/main/43%20%D0%A1%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D0%BD%D1%8B%D0%B5%20%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B%20%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F/IMG/8.JPG)

• Если нужно добавить новую бизнес-логику, но наследование использовать не хочется или нельзя
• Если хочется добавлять обязанности объектам «на лету» незаметно для использующего кода

Добавляет новый функционал к розетке При этом не меняет интерфейс и не контролирует работу устройства

## Decorator / Wrapper (обертка)
+ Большая гибкость, чем у наследования.
+ Позволяет добавлять обязанности на лету.
+ Можно добавлять несколько новых обязанностей сразу.
+ Позволяет иметь несколько мелких объектов вместо одного объекта на все случаи жизни.

- Трудно конфигурировать многократно обёрнутые объекты.
- Обилие крошечных классов.

## Сравнение паттернов

![img](https://github.com/IlyaGall/C-/blob/main/43%20%D0%A1%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D0%BD%D1%8B%D0%B5%20%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B%20%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F/IMG/9.JPG)

## Bridge (мост)


Проблема:
Есть две разных иерархии, которые могут соединяться в разных комбинациях
Нужно реализовать их комбинации

![img](https://github.com/IlyaGall/C-/blob/main/43%20%D0%A1%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D0%BD%D1%8B%D0%B5%20%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B%20%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F/IMG/10.JPG)

![img](https://github.com/IlyaGall/C-/blob/main/43%20%D0%A1%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D0%BD%D1%8B%D0%B5%20%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B%20%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F/IMG/11.JPG)

+ Помогает реализовать Open-Close Principle 

- Дополнительные классы

## Flyweight (легковес)

Проблема:
Существует класс, у которого предполагается большое количество экземпляров. Нужно оптимизировать данные в этом классе

![img](https://github.com/IlyaGall/C-/blob/main/43%20%D0%A1%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D0%BD%D1%8B%D0%B5%20%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B%20%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F/IMG/12.JPG)

• Если нужно сэкономить оперативную память при большом количестве объектов

+ Экономит оперативную память.
- Расходует процессорное время на поиск/вычисление контекста.
- Усложняет код программы из-за введения множества дополнительных классов.




## Composite (компоновщик)

Проблема:
Существуют однотипные объекты, у каждого из которых реализована операция. Нужно уметь выполнить эту операцию над любой иерархией этих объектов


![img](https://github.com/IlyaGall/C-/blob/main/43%20%D0%A1%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D0%BD%D1%8B%D0%B5%20%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B%20%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F/IMG/13.JPG)


• Если нужна работа с группой объектов как с единым объектом (через древовидную структуру)

![img](https://github.com/IlyaGall/C-/blob/main/43%20%D0%A1%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D0%BD%D1%8B%D0%B5%20%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B%20%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F/IMG/14.JPG)

![img](https://github.com/IlyaGall/C-/blob/main/43%20%D0%A1%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D0%BD%D1%8B%D0%B5%20%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B%20%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F/IMG/15.JPG)



