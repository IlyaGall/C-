# Порождающие шаблоны проектирования

## Управление сложностью разработки ПО на этапе проектирования архитектуры

### Проблема сложности при разработке ПО

Количество ресурсов , связей и компонентов, которые требуются для решения какой-либо задачи растет нелинейно по мере роста проекта.

Некоторые виды “сложности”:
- алгоритмическая
- трудоемкость разработки
- информационная
- сложность тестирования

![img](https://github.com/IlyaGall/C-/blob/main/42%20%D0%9F%D0%BE%D1%80%D0%BE%D0%B6%D0%B4%D0%B0%D1%8E%D1%89%D0%B8%D0%B5%20%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B%20%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F/IMG/1.JPG)

### Уровни архитектуры

* инфраструктура (система) (паттерны межсервисноговзаимодействия)
* компоненты системы (сервисы) (+ solid / patterns)
* модули проекта (+ solid / patterns)
* классы (+ solid / patterns)
* методы (+ clean code)

### SOLID

SOLID – 5 основных принципов объектно-ориентированного программирования и проектирования:
* Принцип единственной ответственности (single responsibility principle, SRP)
* Принцип открытости/закрытости (open-closed principle, OCP)
* Принцип подстановки Лисков (Liskov substitution principle, LSP)
* Принцип разделения интерфейса (interface segregation principle, ISP)
* Принцип инверсии зависимостей (dependency inversion principle, DIP)

### Классификация паттернов ООП по GoF

* Порождающие паттерны дают возможность выполнять инициализацию объектов наиболее удобным и оптимальным способом.
* Структурные паттерны описывают взаимоотношения между различными классами или объектами, позволяя им совместно реализовывать поставленную задачу.
* Поведенческие паттерны позволяют грамотно организовать связь между сущностями для оптимизации и упрощения их взаимодействия.

![img](https://github.com/IlyaGall/C-/blob/main/42%20%D0%9F%D0%BE%D1%80%D0%BE%D0%B6%D0%B4%D0%B0%D1%8E%D1%89%D0%B8%D0%B5%20%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B%20%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F/IMG/2.JPG)

## Порождающие паттерны проектирования

### Порождающие паттерны проектирования

Порождающие паттерны отвечают за удобное и безопасное создание новых объектов или даже целых семейств объектов.

При этом могут использоваться следующие механизмы:

* Наследование, когда базовый класс определяет интерфейс, а подклассы - реализацию. Структуры на основе наследования получаются статичными.
* Композиция, когда структуры строятся путем объединения объектов некоторых классов. Композиция позволяет получать структуры, которые можно изменять во время выполнения (рекомендуемый метод)

### Порождающие паттерны проектирования
Список порождающих шаблонов проектирования:
* Фабричный метод (Fabric Method)(Virtual Constructor )
* Абстрактная фабрика (Abstract Factory)(Kit)
* Строитель(Builder)
* Прототип (Prototype)
* Одиночка (Singleton)

### Фабричный метод (Factory Method)(Virtual Constructor )

Определяет интерфейс для создания объекта, но оставляет подклассам решение о том, экземпляры какого класса должны создаваться. Фабричный метод позволяет классу делегировать создание экземпляров подклассам.

Основные условия для применения паттерна фабричный метод:
* классу заранее неизвестно, объекты каких классов ему нужно создавать;
* класс спроектирован так, чтобы объекты, которые он создает, определялись подклассами;
* класс делегирует свои обязанности одному из нескольких вспомогательных подклассов, и вам нужно локализовать информацию о том, какой класс принимает эти обязанности на себя

![img](https://github.com/IlyaGall/C-/blob/main/42%20%D0%9F%D0%BE%D1%80%D0%BE%D0%B6%D0%B4%D0%B0%D1%8E%D1%89%D0%B8%D0%B5%20%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B%20%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F/IMG/3.JPG)

### Фабричный метод (Factory Method)(Virtual Constructor )

![img](https://github.com/IlyaGall/C-/blob/main/42%20%D0%9F%D0%BE%D1%80%D0%BE%D0%B6%D0%B4%D0%B0%D1%8E%D1%89%D0%B8%D0%B5%20%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B%20%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F/IMG/4.JPG)

![img](https://github.com/IlyaGall/C-/blob/main/42%20%D0%9F%D0%BE%D1%80%D0%BE%D0%B6%D0%B4%D0%B0%D1%8E%D1%89%D0%B8%D0%B5%20%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B%20%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F/IMG/5.JPG)

### Абстрактная фабрика (Abstract Factory)(Kit)

Предоставляет интерфейс для создания семейств взаимосвязанных или взаимозависимых объектов, не специфицируя их конкретных классов.

Основные условия применения паттерна:
* система не должна зависеть от того, как создаются, компонуются и представляются входящие в нее объекты;
* система должна настраиваться одним из семейств объектов;
* входящие в семейство взаимосвязанные объекты спроектированы для совместной работы, и вы должны обеспечить выполнение этого ограничения;
* вы хотите предоставить библиотеку объектов, раскрывая только их интерфейсы, но не реализацию.

![img](https://github.com/IlyaGall/C-/blob/main/42%20%D0%9F%D0%BE%D1%80%D0%BE%D0%B6%D0%B4%D0%B0%D1%8E%D1%89%D0%B8%D0%B5%20%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B%20%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F/IMG/6.JPG)

![img](https://github.com/IlyaGall/C-/blob/main/42%20%D0%9F%D0%BE%D1%80%D0%BE%D0%B6%D0%B4%D0%B0%D1%8E%D1%89%D0%B8%D0%B5%20%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B%20%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F/IMG/7.JPG)

![img](https://github.com/IlyaGall/C-/blob/main/42%20%D0%9F%D0%BE%D1%80%D0%BE%D0%B6%D0%B4%D0%B0%D1%8E%D1%89%D0%B8%D0%B5%20%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B%20%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F/IMG/8.JPG)

### Строитель(Builder)

Отделяет конструирование сложного объекта от его представления, так что в результате одного и того же процесса конструирования могут получаться разные представления.

Основные условия для применения паттерна:
* алгоритм создания сложного объекта не должен зависеть от того, из каких частей состоит объект и как они стыкуются между собой;
* процесс конструирования должен обеспечивать различные представления конструируемого объекта.

![img](https://github.com/IlyaGall/C-/blob/main/42%20%D0%9F%D0%BE%D1%80%D0%BE%D0%B6%D0%B4%D0%B0%D1%8E%D1%89%D0%B8%D0%B5%20%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B%20%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F/IMG/9.JPG)

![img](https://github.com/IlyaGall/C-/blob/main/42%20%D0%9F%D0%BE%D1%80%D0%BE%D0%B6%D0%B4%D0%B0%D1%8E%D1%89%D0%B8%D0%B5%20%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B%20%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F/IMG/10.JPG)

![img](https://github.com/IlyaGall/C-/blob/main/42%20%D0%9F%D0%BE%D1%80%D0%BE%D0%B6%D0%B4%D0%B0%D1%8E%D1%89%D0%B8%D0%B5%20%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B%20%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F/IMG/11.JPG)

### Прототип (Клон, Prototype)

Задает виды создаваемых объектов с помощью экземпляра-прототипа и создает новые объекты путем копирования этого прототипа.

Система не должна зависеть от того, как в ней создаются, компонуются и представляются продукты; кроме того:
* классы для создания экземпляров определяются во время выполнения, например с помощью динамической загрузки; или
* для того чтобы избежать построения иерархий классов или фабрик, параллельных иерархии классов продуктов; или
* экземпляры класса могут находиться в одном из не очень большого числа различных состояний. Может быть удобнее установить соответствующее число прототипов и клонировать их, а не создавать экземпляр каждый раз вручную в подходящем состоянии.

![img](https://github.com/IlyaGall/C-/blob/main/42%20%D0%9F%D0%BE%D1%80%D0%BE%D0%B6%D0%B4%D0%B0%D1%8E%D1%89%D0%B8%D0%B5%20%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B%20%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F/IMG/12.JPG)

![img](https://github.com/IlyaGall/C-/blob/main/42%20%D0%9F%D0%BE%D1%80%D0%BE%D0%B6%D0%B4%D0%B0%D1%8E%D1%89%D0%B8%D0%B5%20%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B%20%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F/IMG/13.JPG)

![img](https://github.com/IlyaGall/C-/blob/main/42%20%D0%9F%D0%BE%D1%80%D0%BE%D0%B6%D0%B4%D0%B0%D1%8E%D1%89%D0%B8%D0%B5%20%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B%20%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F/IMG/14.JPG)

### Одиночка (Singleton)

Гарантирует, что у класса существует только один экземпляр, и предоставляет к  нему глобальную точку доступа.
Основные условия для применения паттерна :
* должен существовать ровно один экземпляр некоторого класса, к которому может обратиться любой клиент через известную точку доступа;
* единственный экземпляр должен расширяться путем порождения подклассов, а клиенты должны иметь возможность работать с расширенным экземпляром без модификации своего кода. 

![img](https://github.com/IlyaGall/C-/blob/main/42%20%D0%9F%D0%BE%D1%80%D0%BE%D0%B6%D0%B4%D0%B0%D1%8E%D1%89%D0%B8%D0%B5%20%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B%20%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F/IMG/15.JPG)

![img](https://github.com/IlyaGall/C-/blob/main/42%20%D0%9F%D0%BE%D1%80%D0%BE%D0%B6%D0%B4%D0%B0%D1%8E%D1%89%D0%B8%D0%B5%20%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B%20%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F/IMG/16.JPG)

![img](https://github.com/IlyaGall/C-/blob/main/42%20%D0%9F%D0%BE%D1%80%D0%BE%D0%B6%D0%B4%D0%B0%D1%8E%D1%89%D0%B8%D0%B5%20%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B%20%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F/IMG/17.JPG)

## Список материалов для изучения
1. Гради Буч “Объектно-ориентированный анализ и проектирование”
2. Фредерик Брукс “Мифический человеко месяц”
3. Влиссидес Джон, Хелм Ричард “Паттерны объектно-ориентированного проектирования”
4. Крейг Ларман «Применение UML и шаблонов проектирования»
5. Сергей Тепляков “Паттерны проектирования на платформе .NET”
6. https://refactoring.guru/ru/design-patterns/creational-patterns
7. https://csharpindepth.com/Articles/Singleton
8. https://habr.com/ru/articles/210288/
9. https://github.com/kamranahmedse/design-patterns-for-humans
10. https://github.com/nemanjarogic/DesignPatternsLibrary
11. https://github.com/nemanjarogic/DesignPatternsLibrary/tree/main/src/CreationalPatterns/Builder/CustomSandwichBuilder
12. https://gitlab.com/otus-demo/professional/creational-design-patterns


## Вопросы


1. Какие проблемы сложности разработки ПО вам известны?
* Алгоритмическая сложность
* Трудоемкость разработки
* Информационная сложность
* Сложность тестирования

2. Какие из нижеперечисленных принципов разработки ПО вам известны?
* KISS
* YAGNI
* BDUF
* DRY
* SOLID
* GRASP
* Бритва Оккама

3. Какие принципы скрываются под аббревиатурой SOLID?
* Принцип единственной ответственности
* Открытость к расширению закрытость от изменений
* Подстановка Барбары Лискофф
* Разделение интерфейсов
* Инверсия зависимостей

4. Какие из нижеперечисленных порождающих паттернов проектирования вам известен и/или применяется вами на практике?
* Фабричный метод (Fabric Method)(Virtual Constructor )
* Абстрактная фабрика (Abstract Factory)(Kit)
* Строитель(Builder)
* Прототип (Prototype)
* Одиночка (Singleton)

5. Какой из следующих порождающих паттернов применяется, когда  должен существовать ровно один экземпляр некоторого класса, к которому может обратиться любой клиент через известную точку доступа  ?
* Одиночка

6. Какой из следующих порождающих паттернов применяется, когда создание объекта осуществляется путем полного или частичного копирования исходного экземпляра класса?
* Прототип

7. Как называется порождающий паттерн проектирования, который отделяет конструирование сложного объекта от его представления, так что в результате одного и того же процесса конструирования могут получаться разные представления?
* Строитель

8. Какой из следующих порождающих паттернов  определяет интерфейс для создания объекта, но оставляет подклассам решение о том, экземпляры какого класса должны создаваться и использует механизм наследования?
* Фабричный метод