# Порождающие шаблоны проектирования

## Управление сложностþĀ разработки ПО на ÿтапе проектированиā архитектурý

### Проблема сложности при разработке ПО

Колиùество ресурсов , свāзей и компонентов, которýе требуĀтсā длā реúениā какой-либо задаùи растет нелинейно по мере роста проекта.

Некоторýе видý “сложности”:
- алгоритмиùескаā
- трудоемкостþ разработки
- информаøионнаā
- сложностþ тестированиā

![img](https://github.com/IlyaGall/C-/blob/main/42%20%D0%9F%D0%BE%D1%80%D0%BE%D0%B6%D0%B4%D0%B0%D1%8E%D1%89%D0%B8%D0%B5%20%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B%20%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F/IMG/1.JPG)

### Уровни архитектурý

● инфраструктура (система) (паттернý межсервисноговзаимодействиā)
● компонентý системý (сервисý) (+ solid / patterns)
● модули проекта (+ solid / patterns)
● классý (+ solid / patterns)
● методý (+ clean code)

### SOLID

SOLID – 5 основнýх принøипов обüектно-ориентированного программированиā и проектированиā:
● Принøип единственной ответственности (single responsibility principle, SRP)
● Принøип открýтости/закрýтости (open-closed principle, OCP)
● Принøип подстановки Лисков (Liskov substitution principle, LSP)
● Принøип разделениā интерфейса (interface segregation principle, ISP)
● Принøип инверсии зависимостей (dependency inversion principle, DIP)

### Классификаøиā паттернов ООП по GoF

* ПорождаĀûие паттернý даĀт возможностþ вýполнāтþ иниøиализаøиĀ обüектов наиболее удобнýм и оптималþнýм способом.
● Структурнýе паттернý описýваĀт взаимоотноúениā между разлиùнýми классами или обüектами, позволāā им совместно реализовýватþ поставленнуĀ задаùу.
● Поведенùеские паттернý позволāĀт грамотно организоватþ свāзþ между суûностāми длā оптимизаøии и упроûениā их взаимодействиā.

![img](https://github.com/IlyaGall/C-/blob/main/42%20%D0%9F%D0%BE%D1%80%D0%BE%D0%B6%D0%B4%D0%B0%D1%8E%D1%89%D0%B8%D0%B5%20%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B%20%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F/IMG/2.JPG)

## ПорождаĀûие паттернý проектированиā

### ПорождаĀûие паттернý проектированиā

ПорождаĀûие паттернý отвеùаĀт за удобное и безопасное создание новýх обüектов или даже øелýх семейств обüектов.

При ÿтом могут исполþзоватþсā следуĀûие механизмý:

● Наследование, когда базовýй класс определāет интерфейс, а подклассý - реализаøиĀ. Структурý на основе наследованиā полуùаĀтсā статиùнýми.
● Композиøиā, когда структурý строāтсā путем обüединениā обüектов некоторýх классов. Композиøиā позволāет полуùатþ структурý, которýе можно изменāтþ во времā вýполнениā (рекомендуемýй метод)

### ПорождаĀûие паттернý проектированиā
Список порождаĀûих úаблонов проектированиā:
● Фабриùнýй метод (Fabric Method)(Virtual Constructor )
● Абстрактнаā фабрика (Abstract Factory)(Kit)
● Строителþ(Builder)
● Прототип (Prototype)
● Одиноùка (Singleton)

### Фабриùнýй метод (Factory Method)(Virtual Constructor )

Определяет интерфейс для создания объекта, но оставляет подклассам решение о том, экземпляры какого класса должны создаваться. Фабричный метод позволяет классу делегировать создание экземпляров подклассам.

Основные условия для применения паттерна фабричный метод:
● классу заранее неизвестно, объекты каких классов ему нужно создавать;
● класс спроектирован так, чтобы объекты, которые он создает, определялись подклассами;
● класс делегирует свои обязанности одному из нескольких вспомогательных подклассов, и вам нужно локализовать информацию о том, какой класс принимает эти обязанности на себя

![img](https://github.com/IlyaGall/C-/blob/main/42%20%D0%9F%D0%BE%D1%80%D0%BE%D0%B6%D0%B4%D0%B0%D1%8E%D1%89%D0%B8%D0%B5%20%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B%20%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F/IMG/3.JPG)

### Фабриùнýй метод (Factory Method)(Virtual Constructor )

![img](https://github.com/IlyaGall/C-/blob/main/42%20%D0%9F%D0%BE%D1%80%D0%BE%D0%B6%D0%B4%D0%B0%D1%8E%D1%89%D0%B8%D0%B5%20%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B%20%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F/IMG/4.JPG)

![img](https://github.com/IlyaGall/C-/blob/main/42%20%D0%9F%D0%BE%D1%80%D0%BE%D0%B6%D0%B4%D0%B0%D1%8E%D1%89%D0%B8%D0%B5%20%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B%20%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F/IMG/5.JPG)

### Абстрактнаā фабрика (Abstract Factory)(Kit)

Предоставляет интерфейс для создания семейств взаимосвязанных или взаимозависимых объектов, не специфицируя их конкретных классов.

Основные условия применения паттерна:
● система не должна зависеть от того, как создаются, компонуются и представляются входящие в нее объекты;
● система должна настраиваться одним из семейств объектов;
● входящие в семейство взаимосвязанные объекты спроектированы для совместной работы, и вы должны обеспечить выполнение этого ограничения;
● вы хотите предоставить библиотеку объектов, раскрывая только их интерфейсы, но не реализацию.

![img](https://github.com/IlyaGall/C-/blob/main/42%20%D0%9F%D0%BE%D1%80%D0%BE%D0%B6%D0%B4%D0%B0%D1%8E%D1%89%D0%B8%D0%B5%20%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B%20%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F/IMG/6.JPG)

![img](https://github.com/IlyaGall/C-/blob/main/42%20%D0%9F%D0%BE%D1%80%D0%BE%D0%B6%D0%B4%D0%B0%D1%8E%D1%89%D0%B8%D0%B5%20%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B%20%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F/IMG/7.JPG)

![img](https://github.com/IlyaGall/C-/blob/main/42%20%D0%9F%D0%BE%D1%80%D0%BE%D0%B6%D0%B4%D0%B0%D1%8E%D1%89%D0%B8%D0%B5%20%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B%20%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F/IMG/8.JPG)

### Строителþ(Builder)

Отделяет конструирование сложного объекта от его представления, так что в результате одного и того же процесса конструирования могут получаться разные представления.

Основные условия для применения паттерна:
● алгоритм создания сложного объекта не должен зависеть от того, из каких частей состоит объект и как они стыкуются между собой;
● процесс конструирования должен обеспечивать различные представления конструируемого объекта.

![img](https://github.com/IlyaGall/C-/blob/main/42%20%D0%9F%D0%BE%D1%80%D0%BE%D0%B6%D0%B4%D0%B0%D1%8E%D1%89%D0%B8%D0%B5%20%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B%20%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F/IMG/9.JPG)

![img](https://github.com/IlyaGall/C-/blob/main/42%20%D0%9F%D0%BE%D1%80%D0%BE%D0%B6%D0%B4%D0%B0%D1%8E%D1%89%D0%B8%D0%B5%20%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B%20%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F/IMG/10.JPG)

![img](https://github.com/IlyaGall/C-/blob/main/42%20%D0%9F%D0%BE%D1%80%D0%BE%D0%B6%D0%B4%D0%B0%D1%8E%D1%89%D0%B8%D0%B5%20%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B%20%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F/IMG/11.JPG)

### Прототип (Клон, Prototype)

Задает виды создаваемых объектов с помощью экземпляра-прототипа и создает новые объекты путем копирования этого прототипа.

Система не должна зависеть от того, как в ней создаются, компонуются и представляются продукты; кроме того:
● классы для создания экземпляров определяются во время выполнения, например с помощью динамической загрузки; или
● для того чтобы избежать построения иерархий классов или фабрик, параллельных иерархии классов продуктов; или
● экземпляры класса могут находиться в одном из не очень большого числа различных состояний. Может быть удобнее установить соответствующее число прототипов и клонировать их, а не создавать экземпляр каждый раз вручную в подходящем состоянии.

![img](https://github.com/IlyaGall/C-/blob/main/42%20%D0%9F%D0%BE%D1%80%D0%BE%D0%B6%D0%B4%D0%B0%D1%8E%D1%89%D0%B8%D0%B5%20%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B%20%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F/IMG/12.JPG)

![img](https://github.com/IlyaGall/C-/blob/main/42%20%D0%9F%D0%BE%D1%80%D0%BE%D0%B6%D0%B4%D0%B0%D1%8E%D1%89%D0%B8%D0%B5%20%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B%20%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F/IMG/13.JPG)

![img](https://github.com/IlyaGall/C-/blob/main/42%20%D0%9F%D0%BE%D1%80%D0%BE%D0%B6%D0%B4%D0%B0%D1%8E%D1%89%D0%B8%D0%B5%20%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B%20%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F/IMG/14.JPG)

### Одиноùка (Singleton)

Гарантирует, ùто у класса суûествует толþко один ÿкземплāр, и предоставлāет к  нему глобалþнуĀ тоùку доступа.
Основнýе условиā длā применениā паттерна :
● должен суûествоватþ ровно один ÿкземплāр некоторого класса, к которому может обратитþсā лĀбой клиент ùерез известнуĀ тоùку доступа;
● единственнýй ÿкземплāр должен расúирāтþсā путем порождениā подклассов, а клиентý должнý иметþ возможностþ работатþ с расúиреннýм ÿкземплāром без модификаøии своего кода. 

![img](https://github.com/IlyaGall/C-/blob/main/42%20%D0%9F%D0%BE%D1%80%D0%BE%D0%B6%D0%B4%D0%B0%D1%8E%D1%89%D0%B8%D0%B5%20%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B%20%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F/IMG/15.JPG)

![img](https://github.com/IlyaGall/C-/blob/main/42%20%D0%9F%D0%BE%D1%80%D0%BE%D0%B6%D0%B4%D0%B0%D1%8E%D1%89%D0%B8%D0%B5%20%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B%20%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F/IMG/16.JPG)

![img](https://github.com/IlyaGall/C-/blob/main/42%20%D0%9F%D0%BE%D1%80%D0%BE%D0%B6%D0%B4%D0%B0%D1%8E%D1%89%D0%B8%D0%B5%20%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B%20%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F/IMG/17.JPG)

## Список материалов длā изуùениā
1. Гради Буù “Обüектно-ориентированнýй анализ и проектирование”
2. Фредерик Брукс “Мифиùеский ùеловеко месāø”
3. Влиссидес Джон, Хелм Риùард “Паттернý обüектно-ориентированного проектированиā”
4. Крейг Ларман «Применение UML и úаблонов проектированиā»
5. Сергей Теплāков “Паттернý проектированиā на платформе .NET”
6. https://refactoring.guru/ru/design-patterns/creational-patterns
7. https://csharpindepth.com/Articles/Singleton
8. https://habr.com/ru/articles/210288/
9. https://github.com/kamranahmedse/design-patterns-for-humans
10. https://github.com/nemanjarogic/DesignPatternsLibrary
11. https://github.com/nemanjarogic/DesignPatternsLibrary/tree/main/src/CreationalPatterns/Builder/CustomSandwichBuilder
12. https://gitlab.com/otus-demo/professional/creational-design-patterns


## Вопросы


1. Какие проблемы сложности разработки ПО вам известны?
* Алгоритмическая сложность
* Трудоемкость разработки
* Информационная сложность
* Сложность тестирования

2. Какие из нижеперечисленных принципов разработки ПО вам известны?
* KISS
* YAGNI
* BDUF
* DRY
* SOLID
* GRASP
* Бритва Оккама

3. Какие принципы скрываются под аббревиатурой SOLID?
* Принцип единственной ответственности
* Открытость к расширению закрытость от изменений
* Подстановка Барбары Лискофф
* Разделение интерфейсов
* Инверсия зависимостей

4. Какие из нижеперечисленных порождающих паттернов проектирования вам известен и/или применяется вами на практике?
* Фабричный метод (Fabric Method)(Virtual Constructor )
* Абстрактная фабрика (Abstract Factory)(Kit)
* Строитель(Builder)
* Прототип (Prototype)
* Одиночка (Singleton)

5. Какой из следующих порождающих паттернов применяется, когда  должен существовать ровно один экземпляр некоторого класса, к которому может обратиться любой клиент через известную точку доступа  ?
* Одиночка

6. Какой из следующих порождающих паттернов применяется, когда создание объекта осуществляется путем полного или частичного копирования исходного экземпляра класса?
* Прототип

7. Как называется порождающий паттерн проектирования, который отделяет конструирование сложного объекта от его представления, так что в результате одного и того же процесса конструирования могут получаться разные представления?
* Строитель

8. Какой из следующих порождающих паттернов  определяет интерфейс для создания объекта, но оставляет подклассам решение о том, экземпляры какого класса должны создаваться и использует механизм наследования?
* Фабричный метод