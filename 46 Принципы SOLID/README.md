# SOLID. Что это?

## Как расшифровать SOLID
1) Single responsibility — принцип единственной ответственности
2) Open-closed — принцип открытости / закрытости
3) Liskov substitution — принцип подстановки Барбары Лисков
4) Interface segregation — принцип разделения интерфейса
5) Dependency inversion — принцип инверсии зависимостей

## Симптомы плохого кода
1) Он замедляет работу
2) Он плохо читаемый, непонятный
3) Fragility. Изменения в одном месте ломают что-то в куче других мест
4) Rigid. Любое небольшое изменение влечет за собой массу изменений повсюду
5) Невозможность переиспользовать подходящий код, так как он делает ещё много чего неподходящего и приходится писать заново


## Single responsibility


Принцип единственной ответственности

«Каждýй программнýй модулþ должен иметþ толþко одну приùину длā изменениā».

```C#
public class UserService
{
    public void Register(string email, string password) 
    {
        if (!ValidateEmail(email))
            throw new ValidationException("Email is not an email");
            var user = new User(email, password);
            SendEmail(new MailMessage(" mysite@nowhere.com ", email) { Subject="HEllo foo" });

        public virtual bool ValidateEmail(string email)
        {
            return email.Contains("@");
        }
        public bool SendEmail(MailMessage message)
        {
            _smtpClient.Send(message);
        }
    }
}
```

## Open/Closed Principle

Принцип открытости / закрытости
«Модули должнý бýтþ открýтý длā расúирениā, но закрýтý длā модификаøий».


## The Liskov Substitution Principle

Принцип подстановки Барбары Лисков Производнýе классý должнý бýтþ доступнý ùерез интерфейс базового класса, при ÿтом полþзователĀ не обāзателþно знатþ разниøу.

### Принцип подстановки Барбары Лисков
Функøии, которýе исполþзуĀт ссýлки на базовýе классý, должнý иметþ возможностþ исполþзоватþ обüектý производнýх классов, не знаā об ÿтом.

Предусловиā в подклассе не могут бýтþ усиленý.  Постусловиā в подклассе не могут бýтþ ослабленý.


Это критерий, которýй описýвает правилþное исполþзование полиморфизма и, в ùастности, наследованиā.

=> у нас правилþнаā иерархиā типов

[img](https://github.com/IlyaGall/C-/blob/main/46%20%D0%9F%D1%80%D0%B8%D0%BD%D1%86%D0%B8%D0%BF%D1%8B%20SOLID/Img/1.JPG)

## Interface Segregation Principle (ISP)

Принцип разделения интерфейса 
Клиентý не должнý бýтþ вýнужденý реализовýватþ интерфейсý, которýе они не исполþзуĀт.

Вместо одного толстого интерфейса предпоùтителþнее исполþзоватþ множество неболþúих интерфейсов, основаннýх на группах методов, каждýй из которýх обслуживает один подмодулþ.

## Dependency Inversion Principle 

Принцип инверсии зависимостей

Вýсокоуровневýе компонентý не должнý зависетþ от низкоуровневýх компонент. И те, и те должнý зависетþ от абстракøий.
Абстракøии не должнý зависетþ от деталей. Детали должнý зависетþ от абстракøий.

[img](https://github.com/IlyaGall/C-/blob/main/46%20%D0%9F%D1%80%D0%B8%D0%BD%D1%86%D0%B8%D0%BF%D1%8B%20SOLID/Img/2.JPG)


### Вопросы
* Какой принцип гласит: «У класса должна быть только одна причина для изменения»?
    - Принцип единой ответственности (SRP)

* Что означает «открыто для расширения, закрыто для модификации» в контексте принципа открытости/закрытости (OCP)? 
    - Классы должны быть спроектированы так, чтобы можно было добавлять новые функциональные возможности без изменения существующего кода.

*  Какой принцип гласит: «Объекты суперкласса должны быть заменямы объектами его подклассов без ущерба для корректности программы»?
    -  Принцип замены Лискова (LSP).

* Что означает разделение интерфейсов в контексте принципа разделения интерфейсов (ISP)?
    -   Интерфейсы не должны предоставлять ненужные методы реализующим классам.

*   Какой принцип гласит: «Модули высокого уровня не должны зависеть от модулей низкого уровня. Оба должны зависеть от абстракций»?
    - Принцип инверсии зависимостей (DIP).

* Какова роль абстракций в контексте принципа инверсии зависимостей (DIP)?
    - Абстракции должны позволять модулям высокого уровня зависеть от них, а не от конкретных реализаций.

* Что из следующего лучше всего описывает принцип единой ответственности (SRP)?
    - У класса должна быть только одна причина для изменения.

* Как можно реализовать принцип открытости/закрытости (OCP) на практике? 
    -  Обеспечивая возможность добавления новых функций без изменения существующего кода.

*  Какой принцип гласит: «Клиенты не должны зависеть от интерфейсов, которые они не используют»?
    - Принцип разделения интерфейсов (ISP).
    
* Как можно провести рефакторинг класса, чтобы он соответствовал принципу единой ответственности (SRP)? 
    - Обеспечивая, чтобы у каждого класса была только одна причина для изменения.