# Стек и очередь

![Image alt](https://github.com/IlyaGall/C-/blob/main/22%20%D0%9E%D1%81%D0%BD%D0%BE%D0%B2%D0%BD%D1%8B%D0%B5%20%D0%BA%D0%BE%D0%BB%D0%BB%D0%B5%D0%BA%D1%86%D0%B8%D0%B8%20%D0%BE%D1%87%D0%B5%D1%80%D0%B5%D0%B4%D1%8C%2C%20%D1%81%D1%82%D0%B5%D0%BA%2C%20%D1%81%D0%BB%D0%BE%D0%B2%D0%B0%D1%80%D1%8C%2C%20%D1%85%D0%B5%D1%88%D1%81%D0%B5%D1%82%20%20%D0%94%D0%97/img/1.JPG)

Стек и очередь имитируют физические процессы FILO и FIFO
## Основные функции стека

* pust - добавить в стек "Сверху" 
* pop - извлечь из стека верхний элемент
* Peek - получить верхний элемент без извлечения

## Основные функции очереди

* Enqueue -  добавить в очередь
* Dequeue - извлечь из очереди
* Peek - получить очередной элемент без извлечения

## Внутреннее устройство

![Image alt](https://github.com/IlyaGall/C-/blob/main/22%20%D0%9E%D1%81%D0%BD%D0%BE%D0%B2%D0%BD%D1%8B%D0%B5%20%D0%BA%D0%BE%D0%BB%D0%BB%D0%B5%D0%BA%D1%86%D0%B8%D0%B8%20%D0%BE%D1%87%D0%B5%D1%80%D0%B5%D0%B4%D1%8C%2C%20%D1%81%D1%82%D0%B5%D0%BA%2C%20%D1%81%D0%BB%D0%BE%D0%B2%D0%B0%D1%80%D1%8C%2C%20%D1%85%D0%B5%D1%88%D1%81%D0%B5%D1%82%20%20%D0%94%D0%97/img/2.JPG)

## Алгоритмическая сложность операций

* Добавление элемента – о(1) (если нужно увеличить вложенный массив, то о(n))
* Удаление элемента, просмотр элемента – о(1)

# Хеш-функция и хеш-таблица
## Упорядоченность и неупорядоченность

![Image alt](https://github.com/IlyaGall/C-/blob/main/22%20%D0%9E%D1%81%D0%BD%D0%BE%D0%B2%D0%BD%D1%8B%D0%B5%20%D0%BA%D0%BE%D0%BB%D0%BB%D0%B5%D0%BA%D1%86%D0%B8%D0%B8%20%D0%BE%D1%87%D0%B5%D1%80%D0%B5%D0%B4%D1%8C%2C%20%D1%81%D1%82%D0%B5%D0%BA%2C%20%D1%81%D0%BB%D0%BE%D0%B2%D0%B0%D1%80%D1%8C%2C%20%D1%85%D0%B5%D1%88%D1%81%D0%B5%D1%82%20%20%D0%94%D0%97/img/3.JPG)


* Array – упорядочена, значит можно перебрать и индексировать
* Set - не упорядочен, значит нельзя перебирать и индексировать

## Неупорядоченная коллекция неповторяющихся элементов
Реализуется классом HashSet<T>
Основные методы
* Add
* Intersect
* Union
* Except

## Алгоритмическая сложность операций
Добавление элемента – о(1) (если нужно увеличить внутренний массив, то о(n))
Удаление элемента, просмотр элемента – о(1)



# Хешсет и словарь

## Хеш-функция
Функция, принимающая на вход информацию произвольной длины, и возвращающая информацию фиксированной длины

![Image alt](https://github.com/IlyaGall/C-/blob/main/22%20%D0%9E%D1%81%D0%BD%D0%BE%D0%B2%D0%BD%D1%8B%D0%B5%20%D0%BA%D0%BE%D0%BB%D0%BB%D0%B5%D0%BA%D1%86%D0%B8%D0%B8%20%D0%BE%D1%87%D0%B5%D1%80%D0%B5%D0%B4%D1%8C%2C%20%D1%81%D1%82%D0%B5%D0%BA%2C%20%D1%81%D0%BB%D0%BE%D0%B2%D0%B0%D1%80%D1%8C%2C%20%D1%85%D0%B5%D1%88%D1%81%D0%B5%D1%82%20%20%D0%94%D0%97/img/4.JPG)


* Достаточно уникальна
* Необратима: по хэшу – не понять, что за исходное сообщение 
* Вычисляется быстро
## применение хеш-сет
* Хранение паролей (достаточно держать хэш пароля, а вводимый пароль – сравнивать по хэшу)
* Электронная подпись
* Контрольные суммы
* Ускорение поиска данных

## Хеш-таблица
Хеш-таблица (hash table, hash map) – структура данных, использующая хэш-функцию для работы с данными

![Image alt](https://github.com/IlyaGall/C-/blob/main/22%20%D0%9E%D1%81%D0%BD%D0%BE%D0%B2%D0%BD%D1%8B%D0%B5%20%D0%BA%D0%BE%D0%BB%D0%BB%D0%B5%D0%BA%D1%86%D0%B8%D0%B8%20%D0%BE%D1%87%D0%B5%D1%80%D0%B5%D0%B4%D1%8C%2C%20%D1%81%D1%82%D0%B5%D0%BA%2C%20%D1%81%D0%BB%D0%BE%D0%B2%D0%B0%D1%80%D1%8C%2C%20%D1%85%D0%B5%D1%88%D1%81%D0%B5%D1%82%20%20%D0%94%D0%97/img/5.JPG)
## получение хеша
![Image alt](https://github.com/IlyaGall/C-/blob/main/22%20%D0%9E%D1%81%D0%BD%D0%BE%D0%B2%D0%BD%D1%8B%D0%B5%20%D0%BA%D0%BE%D0%BB%D0%BB%D0%B5%D0%BA%D1%86%D0%B8%D0%B8%20%D0%BE%D1%87%D0%B5%D1%80%D0%B5%D0%B4%D1%8C%2C%20%D1%81%D1%82%D0%B5%D0%BA%2C%20%D1%81%D0%BB%D0%BE%D0%B2%D0%B0%D1%80%D1%8C%2C%20%D1%85%D0%B5%D1%88%D1%81%D0%B5%D1%82%20%20%D0%94%D0%97/img/6.JPG)

для получения хеша нужно использовать формулу = ключ(значение) % размер таблицы(массива)

```C#
/// <summary>
/// Получить key при помощи хеш таблицы
/// </summary>
/// <param name="key"> Ключ </param>
/// <returns>Хеш - ключ</returns>
private int HashKey(int key) => key % _size;
```
## Коллизии

При расчете ключа по формуле выше, можно получить коллизию, например, для числа 8 и 40 при размере массива 32.

И для разрешения Коллизии можно использовать 2 подхода 
* открытая адресация, когда при появлении Коллизии можно записать число в любую свободную ячейку
* закрытая, когда при возникновении колизии создовать массив value

![Image alt](https://github.com/IlyaGall/C-/blob/main/22%20%D0%9E%D1%81%D0%BD%D0%BE%D0%B2%D0%BD%D1%8B%D0%B5%20%D0%BA%D0%BE%D0%BB%D0%BB%D0%B5%D0%BA%D1%86%D0%B8%D0%B8%20%D0%BE%D1%87%D0%B5%D1%80%D0%B5%D0%B4%D1%8C%2C%20%D1%81%D1%82%D0%B5%D0%BA%2C%20%D1%81%D0%BB%D0%BE%D0%B2%D0%B0%D1%80%D1%8C%2C%20%D1%85%D0%B5%D1%88%D1%81%D0%B5%D1%82%20%20%D0%94%D0%97/img/7.JPG)

![Image alt](https://github.com/IlyaGall/C-/blob/main/22%20%D0%9E%D1%81%D0%BD%D0%BE%D0%B2%D0%BD%D1%8B%D0%B5%20%D0%BA%D0%BE%D0%BB%D0%BB%D0%B5%D0%BA%D1%86%D0%B8%D0%B8%20%D0%BE%D1%87%D0%B5%D1%80%D0%B5%D0%B4%D1%8C%2C%20%D1%81%D1%82%D0%B5%D0%BA%2C%20%D1%81%D0%BB%D0%BE%D0%B2%D0%B0%D1%80%D1%8C%2C%20%D1%85%D0%B5%D1%88%D1%81%D0%B5%D1%82%20%20%D0%94%D0%97/img/8.JPG)

![Image alt](https://github.com/IlyaGall/C-/blob/main/22%20%D0%9E%D1%81%D0%BD%D0%BE%D0%B2%D0%BD%D1%8B%D0%B5%20%D0%BA%D0%BE%D0%BB%D0%BB%D0%B5%D0%BA%D1%86%D0%B8%D0%B8%20%D0%BE%D1%87%D0%B5%D1%80%D0%B5%D0%B4%D1%8C%2C%20%D1%81%D1%82%D0%B5%D0%BA%2C%20%D1%81%D0%BB%D0%BE%D0%B2%D0%B0%D1%80%D1%8C%2C%20%D1%85%D0%B5%D1%88%D1%81%D0%B5%D1%82%20%20%D0%94%D0%97/img/9.JPG)


## Словарь

Коллекция сопоставления ключа и значения
Реализуется при помощи Dictionary<TKey, TValue>
Позволяет реализовать доступ к значению по ключу за постоянное время

* Внутри – 2 массива: buckets и entries
* buckets – массив с индексами элементов из entries
* entries – последовательный массив элементов для хранения

Берется key.GetHashCode() (hash)
Вычисляется bucketsIndex = (hash & 0x7fffffff) % capacity, где capacity – размер текущего словаря
В bucketsIndex пишется следующий свободный индекс entries - freeIndex
В entries[freeIndex] пишется значение
Если entries закончился – увеличиваем размер и перехешируем

## Алгоритмическая сложность операций
Добавление элемента – о(1) (если нужно увеличить внутренний массив, то о(n))
Удаление элемента, просмотр элемента – о(1)

## Алгоритмическая сложность операций
Добавление элемента – о(1) (если нужно увеличить внутренний массив, то о(n))
Удаление элемента, просмотр элемента – о(1)
