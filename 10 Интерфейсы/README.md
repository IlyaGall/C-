## Интерфейсы
### Определение

Интерфейс в C# — это контракт, определяющий набор методов, свойств, событий или индексаторов, которые должен реализовать класс или структура.
В отличие от классов, интерфейсы не предоставляют никакой реализации для определяемых ими членов; они только определяют члены, которые должны быть реализованы.

### Соглашения по использованию интерфейса
Соглашения:
- Находится в отдельном файле
- Название начинается на “I”
- Если в названии нужно обозначить признак по действию, добавляется “-able” (IDisposable, IClonable)
### Члены интерфейса
* Метод: void Method1() должен быть реализован любым классом, реализующим IExample.
* Свойство: int Property1 { get; set; } должно быть реализовано, включая как геттер, так и сеттер.
* Событие: event EventHandler Event1 должно быть реализовано для обработки событий.
* Индексатор: string this[int index] { get; set; } должно быть реализовано для индексации.
* Константа: const int ConstantValue = 42 предоставляет постоянное значение, которое нельзя изменить.
* Метод по умолчанию: void DefaultMethod() предоставляет реализацию по умолчанию, которая может быть опционально переопределена реализующим классом

```c#
    public interface IExtample 
    {
        /// <summary>
        /// декларативный метод
        /// </summary>
        void method1();
        /// <summary>
        /// защищенный
        /// </summary>
        int property1 { get; set; }
        /// <summary>
        /// ивент 
        /// </summary>
        event EventHandler event1;

        /// <summary>
        /// индексатор метод
        /// </summary>
        /// <param name="index"></param>
        /// <returns></returns>
        string this[int index] { get;set; }

        /// <summary>
        ///константа
        /// </summary>
        const int constantValue = 42;

        /// <summary>
        /// метод по умолчанию
        /// </summary>
        void defaultMethod() 
        {
            Console.WriteLine();
        }
    }
```
### Различия между классом и интерфейсом

![Image alt](https://github.com/IlyaGall/C-/blob/main/10%20%D0%98%D0%BD%D1%82%D0%B5%D1%80%D1%84%D0%B5%D0%B9%D1%81%D1%8B/img/1.PNG)

![Image alt](https://github.com/IlyaGall/C-/blob/main/10%20%D0%98%D0%BD%D1%82%D0%B5%D1%80%D1%84%D0%B5%D0%B9%D1%81%D1%8B/img/2.PNG)


Сценарии использования
* Определение общего поведения: Интерфейсы могут определять набор методов, которые должны реализовывать несколько классов. Это обеспечивает согласованность между различными типами.
Пример: интерфейс IComparable позволяет сравнивать объекты разных классов.
* Разделение кода: Интерфейсы помогают отделить реализацию класса от кода, который использует этот класс. Это делает код более модульным и простым в обслуживании.
Пример: интерфейс ILogger может быть реализован различными классами ведения журнала, такими как FileLogger и DatabaseLogger.
* Полиморфизм: Интерфейсы обеспечивают полиморфное поведение, позволяя одному методу работать с объектами разных классов, реализующих один и тот же интерфейс.
Пример: метод, обрабатывающий список объектов IAnimal, может работать с любым классом, реализующим интерфейс IAnimal.

● Модулþное тестирование и имитаøиā: Интерфейсý обýùно исполþзуĀтсā в модулþном тестировании длā созданиā имитаøионнýх реализаøий зависимостей.
Пример: интерфейс IEmailService может бýтþ имитаøией длā проверки функøионалþности класса, которýй отправлāет ÿлектроннýе писþма без фактиùеской отправки ÿлектроннýх писем.
● Расúирение функøионалþности: Интерфейсý можно исполþзоватþ длā расúирениā функøионалþности класса без изменениā его исходного кода.
Пример: интерфейс IDisposable можно реализоватþ длā предоставлениā логики оùистки неуправлāемýх ресурсов.

```c#
    public interface IPaymentProcessor

    {
        void ProcessPayment(decimal amount);
    }
    public class PayPalProcessor : IPaymentProcessor
    {
        public void ProcessPayment(decimal amount)
        {
            Console.WriteLine($"Processing PayPal payment of {amount:C}.");
        }
    }
    public class CreditCardProcessor : IPaymentProcessor
    {
        public void ProcessPayment(decimal amount)
        {
            Console.WriteLine($"Processing credit card payment of {amount:C}.");
        }
    }
```

## Композициā интерфейсов

Определение композициā
- Композиøиā интерфейса предполагает обüединение несколþких интерфейсов длā созданиā более сложнýх и универсалþнýх типов. Это позволāет классу реализоватþ несколþко интерфейсов, тем самýм наследуā контракт несколþких истоùников и способствуā луùúей организаøии и гибкости кода.
```c#
    public interface IPrintable
    {
        void Print();
    }
    public interface IScannable
    {
        void Scan();
    }
    
```
### Преимущества
* Разделение и гибкостþ: Композиøиā интерфейсов помогает разделитþ функøионалþностþ в системе. Разбиваā сложнýе функøии на bболее мелкие, спеøиализированнýе интерфейсý, вý можете создатþ более гибкий и поддерживаемýй код.
* Повторное исполþзование: Когда функøионалþностþ определāетсā в неболþúих, одноøелевýх интерфейсах, ее можно повторно исполþзоватþ в несколþких классах. Это предотвраûает дублирование кода и способствует согласованности.
* Полиморфизм: Композиøиā интерфейсов позволāет рассматриватþ класс как несколþко типов. Этот полиморфизм особенно полезен при проектировании систем, которýм необходимо работатþ с разлиùнýми обüектами ùерез обûий интерфейс.
* Поддерживаемостþ: Менþúие интерфейсý легùе пониматþ и поддерживатþ. Изменениā одного интерфейса не влиāĀт на другие, ùто снижает риск оúибок и упроûает расúирение системý.

```c#
    public interface IPrintable

    {
        void Print();
    }
    public interface IScannable
    {
        void Scan();
    }

    public class multiFunctionbevice : IPrintable, IScannable
    {

        public void Print()

        {
            Console.WriteLine("Printing document...");
        }
        public void Scan()
        {

            Console.WriteLine("Scanning document.");
        }
    }
```