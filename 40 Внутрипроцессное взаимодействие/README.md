# Внутрипроцессное взаимодействие

## Однопоточная и многопоточная модель процесса

![img](https://github.com/IlyaGall/C-/blob/main/40%20%D0%92%D0%BD%D1%83%D1%82%D1%80%D0%B8%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81%D0%BD%D0%BE%D0%B5%20%D0%B2%D0%B7%D0%B0%D0%B8%D0%BC%D0%BE%D0%B4%D0%B5%D0%B9%D1%81%D1%82%D0%B2%D0%B8%D0%B5/IMG/1.JPG)

### Многопоточность

Использовать несколько ядер легко для большинства серверных приложений, где каждый поток может независимо обрабатывать отдельный клиентский запрос, но сложнее на настольных компьютерах, поскольку обычно требуется, чтобы вы взяли код с интенсивными вычислениями и сделали следующее:
1. Разделите его на небольшие куски.
2. Выполняйте эти фрагменты параллельно с помощью многопоточности.
3. Сопоставляйте результаты по мере их поступления, потокобезопасным и производительным способом.

### Параллелизм 

Существует две стратегии разделения работы между потоками:
* Параллелизм данных
* лучше масштабируется
* уменьшает конфликты
* структурированный
* менее подвержен ошибкам
2. Параллелизм задач

### Модели параллелизма в программах

**Императивный параллелизм задач**. Явное выражение операторов программы, выполнение которых должно быть выполнено параллельно. 

*Пример*: Явное использование потоков в программировании.

**Императивный параллелизм данных**. Необходимо выразить императивный оператор, ориентированный на обработку данных. Параллелизм выполнения оператора - задача среды разработки.
*Пример*: операторы for, foreach (в PLINQ).

**Декларативный параллелизм данных.** Необходимо выразить желаемый результат обработки данных. Параллелизм выполнения - задача среды разработки.
*Пример*: SQL, PLINQ.


### Преимущества использования потоков
• Создание потока занимает меньше времени, чем создание процесса.
• Поток можно завершить быстрее, чем процесс.
• Переключение между потоками процесса происходит намного быстрее.
• Потоки одного процесса разделяют его ресурсы, что позволяет потокам
взаимодействовать без привлечения ядра ОС. 

### Потоки на однопроцессорной системе
• Работа в приоритетном (foreground) и фоновых режимах (background).
• Электронные таблицы
• Асинхронная обработка
• Работа с низкопроизводительными устройствами
•Повышение скорости выполнения
• Одновременные операции по загрузке и обработке данных
• Модульная структура программы
• Осуществление разнообразных действий и/или выполняющие множество
операций ввода-вывода из и на различные источники.

### Основные состояния потока
• События, изменяющие состояние потока
1. Порождение (Spawn)
• Первичный поток процесса порождается ОС. Другие потоки процесса порождаются потоками
(начиная с первичного).
• Новый поток создаётся со своим контекстом и стеками и помещается в очередь готовых к
выполнению.
2. Блокирование
• Ожидание некоторого события с сохранением контекста
• Процессор переходит к выполнению другого потока.
3. Разблокирование
• Наступление события и перевод потока в готовое состояние
4. Завершение
• Разрушение контекста и стеков потока.
• Приостановка (Suspending) процесса приводит к простановке всех его потоков
• Завершение процесса приводит к завершению всех его потоков.

### Потоки в C#
```c#
Thread t = Thread.CurrentThread; // получаем текущий поток
Console.WriteLine($"Имя потока: {t.Name}"); //получаем имя потока, состояние и др.
Console.WriteLine($"Статус потока: {t.ThreadState}");
Console.WriteLine($"Домен приложения: {Thread.GetDomain().FriendlyName}");

Thread thread = new Thread(new ThreadStart(метод)); // создаем новый поток
thread.Start(); // запускаем поток // создаем новый поток
Thread thread = new Thread(new ParameterizedThreadStart(метод, принимающий object));
thread.Start(параметр);
TimerCallback tm = new TimerCallback(метод); // устанавливаем метод обратного вызова
Timer timer = new Timer(tm, num, 0, 2000); // создаем таймер
```

### Задачи в C#
```c#
Task task = new Task(() => Console.WriteLine("Hello Task!"));
task.Start();
task.Wait();
Task task = Task.Run(() => Console.WriteLine("Hello Task!"));
Task task = Task.Factory.StartNew(() => Console.WriteLine("Hello Task!"));
```

### Закон Амдала

Проблемой в использовании многоядерности является закон Амдала, который гласит, что максимальное улучшение производительности за счет распараллеливания определяется частью кода, которая должна выполняться последовательно. Например, если только две трети времени выполнения алгоритма можно распараллелить, вы никогда не сможете превысить трехкратный прирост производительности - даже при бесконечном количестве ядер.

![img](https://github.com/IlyaGall/C-/blob/main/40%20%D0%92%D0%BD%D1%83%D1%82%D1%80%D0%B8%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81%D0%BD%D0%BE%D0%B5%20%D0%B2%D0%B7%D0%B0%D0%B8%D0%BC%D0%BE%D0%B4%D0%B5%D0%B9%D1%81%D1%82%D0%B2%D0%B8%D0%B5/IMG/2.JPG)

## Декларативный параллелизм задач

```c#
Parallel.Invoke(массив делегатов);
Parallel.For(1, 10, метод обработки);
Parallel.ForEach<int>(new List<int>() { 1, 3, 5, 8 },
метод обработки);
```
## Декларативный параллелизм данных
### Parallel LINQ

```c#
static void Main(string[] args)
{
int[] numbers = new int[] { 1, 2, 3, 4, 5, 6, 7, 8, }; 
var results = from n in numbers.AsParallel()
    select МетодВычисления(n);
foreach (var n in results)
{Console.WriteLine(n);}
Console.ReadLine();
}
```
.AsOrdered()
.AsUnordered()
.ForAll()
.WithCancellation(new CancellationTokenSource().Token)

![img](https://github.com/IlyaGall/C-/blob/main/40%20%D0%92%D0%BD%D1%83%D1%82%D1%80%D0%B8%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81%D0%BD%D0%BE%D0%B5%20%D0%B2%D0%B7%D0%B0%D0%B8%D0%BC%D0%BE%D0%B4%D0%B5%D0%B9%D1%81%D1%82%D0%B2%D0%B8%D0%B5/IMG/3.JPG)

### Методы Parallel LINQ

![img](https://github.com/IlyaGall/C-/blob/main/40%20%D0%92%D0%BD%D1%83%D1%82%D1%80%D0%B8%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81%D0%BD%D0%BE%D0%B5%20%D0%B2%D0%B7%D0%B0%D0%B8%D0%BC%D0%BE%D0%B4%D0%B5%D0%B9%D1%81%D1%82%D0%B2%D0%B8%D0%B5/IMG/4.JPG)

### AsSequential

AsSequential() необходимо перед вызовом методов, которые имеют побочные эффекты или не являются потокобезопасными.

Для операторов запроса, которые принимают две входные последовательности ( Join, GroupJoin, Concat, Union, Intersect, Except и Zip), необходимо применить AsParallel() к обеим входным последовательностям (в противном случае выдается исключение).

```c#
mySequence.AsParallel()// Wraps sequence in ParallelQuery<int>
.Where (n => n > 100) // Outputs another ParallelQuery<int>
.AsParallel() // Unnecessary - and inefficient!
.Select (n => n * n)
```

### AsOrdered, AsUnordered

Вызов AsOrdered приводит к снижению производительности при большом количестве элементов, поскольку PLINQ должен отслеживать исходное положение каждого элемента.

Вы можете свести на нет эффект AsOrdered последующего выполнения запроса, вызвав AsUnordered: это вводит «случайную точку перемешивания», которая позволяет запросу выполняться более эффективно с этого момента.


```c#
inputSequence.AsParallel().AsOrdered()
.Query0perator1()
.Query0perator2()
.AsUnordered()// From here on, ordering doesn't matter
.QueryOperator3()
```

### Ограничения Parallel LINQ

1. PLINQ не всегда работает параллельно:
Следующие операторы запроса предотвращают распараллеливание запроса, если только исходные элементы не находятся в исходной индексной позиции:

**Take, TakeWhile, Skip, и SkipWhile**

Следующие операторы запроса можно распараллелить, но они используют дорогостоящую стратегию секционирования, которая иногда может быть медленнее, чем последовательная обработка:

**Join, GroupBy, GroupJoin, Distinct, Union, Intersect и Except**

2. PLINQ предназначен только для локальных коллекций: он не работает с LINQ to SQL или Entity Framework
3. Если запрос PLINQ выдает исключение, оно выдается повторно как свойство, AggregateExceptionчье InnerExceptions свойство содержит реальное исключение (или исключения).

### Дополнительные методы Parallel LINQ

35 слайд



